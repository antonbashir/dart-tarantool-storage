// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for Tarantool
class TarantoolBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TarantoolBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TarantoolBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int imaxabs(
    int __n,
  ) {
    return _imaxabs(
      __n,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int wcstoimax(
    ffi.Pointer<ffi.Int> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Int>>, int)>();

  int wcstoumax(
    ffi.Pointer<ffi.Int> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Int>>, int)>();

  /// Is this an error handle?
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsError(
    Object handle,
  ) {
    return _Dart_IsError(
      handle,
    );
  }

  late final _Dart_IsErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsError');
  late final _Dart_IsError =
      _Dart_IsErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an api error handle?
  ///
  /// Api error handles are produced when an api function is misused.
  /// This happens when a Dart embedding api function is called with
  /// invalid arguments or in an invalid context.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsApiError(
    Object handle,
  ) {
    return _Dart_IsApiError(
      handle,
    );
  }

  late final _Dart_IsApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsApiError');
  late final _Dart_IsApiError =
      _Dart_IsApiErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an unhandled exception error handle?
  ///
  /// Unhandled exception error handles are produced when, during the
  /// execution of Dart code, an exception is thrown but not caught.
  /// This can occur in any function which triggers the execution of Dart
  /// code.
  ///
  /// See Dart_ErrorGetException and Dart_ErrorGetStackTrace.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsUnhandledExceptionError(
    Object handle,
  ) {
    return _Dart_IsUnhandledExceptionError(
      handle,
    );
  }

  late final _Dart_IsUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsUnhandledExceptionError');
  late final _Dart_IsUnhandledExceptionError =
      _Dart_IsUnhandledExceptionErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a compilation error handle?
  ///
  /// Compilation error handles are produced when, during the execution
  /// of Dart code, a compile-time error occurs.  This can occur in any
  /// function which triggers the execution of Dart code.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsCompilationError(
    Object handle,
  ) {
    return _Dart_IsCompilationError(
      handle,
    );
  }

  late final _Dart_IsCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsCompilationError');
  late final _Dart_IsCompilationError =
      _Dart_IsCompilationErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a fatal error handle?
  ///
  /// Fatal error handles are produced when the system wants to shut down
  /// the current isolate.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsFatalError(
    Object handle,
  ) {
    return _Dart_IsFatalError(
      handle,
    );
  }

  late final _Dart_IsFatalErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFatalError');
  late final _Dart_IsFatalError =
      _Dart_IsFatalErrorPtr.asFunction<bool Function(Object)>();

  /// Gets the error message from an error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A C string containing an error message if the handle is
  /// error. An empty C string ("") if the handle is valid. This C
  /// String is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_GetError(
    Object handle,
  ) {
    return _Dart_GetError(
      handle,
    );
  }

  late final _Dart_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>(
          'Dart_GetError');
  late final _Dart_GetError =
      _Dart_GetErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(Object)>();

  /// Is this an error handle for an unhandled exception?
  bool Dart_ErrorHasException(
    Object handle,
  ) {
    return _Dart_ErrorHasException(
      handle,
    );
  }

  late final _Dart_ErrorHasExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_ErrorHasException');
  late final _Dart_ErrorHasException =
      _Dart_ErrorHasExceptionPtr.asFunction<bool Function(Object)>();

  /// Gets the exception Object from an unhandled exception error handle.
  Object Dart_ErrorGetException(
    Object handle,
  ) {
    return _Dart_ErrorGetException(
      handle,
    );
  }

  late final _Dart_ErrorGetExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetException');
  late final _Dart_ErrorGetException =
      _Dart_ErrorGetExceptionPtr.asFunction<Object Function(Object)>();

  /// Gets the stack trace Object from an unhandled exception error handle.
  Object Dart_ErrorGetStackTrace(
    Object handle,
  ) {
    return _Dart_ErrorGetStackTrace(
      handle,
    );
  }

  late final _Dart_ErrorGetStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetStackTrace');
  late final _Dart_ErrorGetStackTrace =
      _Dart_ErrorGetStackTracePtr.asFunction<Object Function(Object)>();

  /// Produces an api error handle with the provided error message.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param error the error message.
  Object Dart_NewApiError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewApiError(
      error,
    );
  }

  late final _Dart_NewApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewApiError');
  late final _Dart_NewApiError =
      _Dart_NewApiErrorPtr.asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  Object Dart_NewCompilationError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewCompilationError(
      error,
    );
  }

  late final _Dart_NewCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewCompilationError');
  late final _Dart_NewCompilationError = _Dart_NewCompilationErrorPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Produces a new unhandled exception error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param exception An instance of a Dart object to be thrown or
  /// an ApiError or CompilationError handle.
  /// When an ApiError or CompilationError handle is passed in
  /// a string object of the error message is created and it becomes
  /// the Dart object to be thrown.
  Object Dart_NewUnhandledExceptionError(
    Object exception,
  ) {
    return _Dart_NewUnhandledExceptionError(
      exception,
    );
  }

  late final _Dart_NewUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewUnhandledExceptionError');
  late final _Dart_NewUnhandledExceptionError =
      _Dart_NewUnhandledExceptionErrorPtr.asFunction<Object Function(Object)>();

  /// Propagates an error.
  ///
  /// If the provided handle is an unhandled exception error, this
  /// function will cause the unhandled exception to be rethrown.  This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If the error is not an unhandled exception error, we will unwind
  /// the stack to the next C frame.  Intervening Dart frames will be
  /// discarded; specifically, 'finally' blocks will not execute.  This
  /// is the standard way that compilation errors (and the like) are
  /// handled by the Dart runtime.
  ///
  /// In either case, when an error is propagated any current scopes
  /// created by Dart_EnterScope will be exited.
  ///
  /// See the additional discussion under "Propagating Errors" at the
  /// beginning of this file.
  ///
  /// \param handle An error handle (See Dart_IsError)
  ///
  /// On success, this function does not return.  On failure, the
  /// process is terminated.
  void Dart_PropagateError(
    Object handle,
  ) {
    return _Dart_PropagateError(
      handle,
    );
  }

  late final _Dart_PropagateErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_PropagateError');
  late final _Dart_PropagateError =
      _Dart_PropagateErrorPtr.asFunction<void Function(Object)>();

  /// Converts an object to a string.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return The converted string if no error occurs during
  /// the conversion. If an error does occur, an error handle is
  /// returned.
  Object Dart_ToString(
    Object object,
  ) {
    return _Dart_ToString(
      object,
    );
  }

  late final _Dart_ToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ToString');
  late final _Dart_ToString =
      _Dart_ToStringPtr.asFunction<Object Function(Object)>();

  /// Checks to see if two handles refer to identically equal objects.
  ///
  /// If both handles refer to instances, this is equivalent to using the top-level
  /// function identical() from dart:core. Otherwise, returns whether the two
  /// argument handles refer to the same object.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  ///
  /// \return True if the objects are identically equal.  False otherwise.
  bool Dart_IdentityEquals(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_IdentityEquals(
      obj1,
      obj2,
    );
  }

  late final _Dart_IdentityEqualsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle, ffi.Handle)>>(
          'Dart_IdentityEquals');
  late final _Dart_IdentityEquals =
      _Dart_IdentityEqualsPtr.asFunction<bool Function(Object, Object)>();

  /// Allocates a handle in the current scope from a persistent handle.
  Object Dart_HandleFromPersistent(
    Object object,
  ) {
    return _Dart_HandleFromPersistent(
      object,
    );
  }

  late final _Dart_HandleFromPersistentPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_HandleFromPersistent');
  late final _Dart_HandleFromPersistent =
      _Dart_HandleFromPersistentPtr.asFunction<Object Function(Object)>();

  /// Allocates a handle in the current scope from a weak persistent handle.
  ///
  /// This will be a handle to Dart_Null if the object has been garbage collected.
  Object Dart_HandleFromWeakPersistent(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_HandleFromWeakPersistent(
      object,
    );
  }

  late final _Dart_HandleFromWeakPersistentPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>(
      'Dart_HandleFromWeakPersistent');
  late final _Dart_HandleFromWeakPersistent = _Dart_HandleFromWeakPersistentPtr
      .asFunction<Object Function(Dart_WeakPersistentHandle)>();

  /// Allocates a persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate unless it is
  /// explicitly deallocated by calling Dart_DeletePersistentHandle.
  ///
  /// Requires there to be a current isolate.
  Object Dart_NewPersistentHandle(
    Object object,
  ) {
    return _Dart_NewPersistentHandle(
      object,
    );
  }

  late final _Dart_NewPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewPersistentHandle');
  late final _Dart_NewPersistentHandle =
      _Dart_NewPersistentHandlePtr.asFunction<Object Function(Object)>();

  /// Assign value of local handle to a persistent handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param obj1 A persistent handle whose value needs to be set.
  /// \param obj2 An object whose value needs to be set to the persistent handle.
  void Dart_SetPersistentHandle(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_SetPersistentHandle(
      obj1,
      obj2,
    );
  }

  late final _Dart_SetPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>(
          'Dart_SetPersistentHandle');
  late final _Dart_SetPersistentHandle =
      _Dart_SetPersistentHandlePtr.asFunction<void Function(Object, Object)>();

  /// Deallocates a persistent handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeletePersistentHandle(
    Object object,
  ) {
    return _Dart_DeletePersistentHandle(
      object,
    );
  }

  late final _Dart_DeletePersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_DeletePersistentHandle');
  late final _Dart_DeletePersistentHandle =
      _Dart_DeletePersistentHandlePtr.asFunction<void Function(Object)>();

  /// Allocates a weak persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate. The handle can also be
  /// explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the peer as
  /// argument. The callback can be executed on any thread, will have a current
  /// isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This
  /// gives the embedder the ability to cleanup data associated with the object.
  /// The handle will point to the Dart_Null object after the finalizer has been
  /// run. It is illegal to call into the VM with any other Dart_* functions from
  /// the callback. If the handle is deleted before the object becomes
  /// unreachable, the callback is never invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The weak persistent handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_WeakPersistentHandle Dart_NewWeakPersistentHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewWeakPersistentHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewWeakPersistentHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_WeakPersistentHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewWeakPersistentHandle');
  late final _Dart_NewWeakPersistentHandle =
      _Dart_NewWeakPersistentHandlePtr.asFunction<
          Dart_WeakPersistentHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given weak persistent [object] handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeleteWeakPersistentHandle(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_DeleteWeakPersistentHandle(
      object,
    );
  }

  late final _Dart_DeleteWeakPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>(
          'Dart_DeleteWeakPersistentHandle');
  late final _Dart_DeleteWeakPersistentHandle =
      _Dart_DeleteWeakPersistentHandlePtr.asFunction<
          void Function(Dart_WeakPersistentHandle)>();

  /// Updates the external memory size for the given weak persistent handle.
  ///
  /// May trigger garbage collection.
  void Dart_UpdateExternalSize(
    Dart_WeakPersistentHandle object,
    int external_allocation_size,
  ) {
    return _Dart_UpdateExternalSize(
      object,
      external_allocation_size,
    );
  }

  late final _Dart_UpdateExternalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_WeakPersistentHandle,
              ffi.IntPtr)>>('Dart_UpdateExternalSize');
  late final _Dart_UpdateExternalSize = _Dart_UpdateExternalSizePtr.asFunction<
      void Function(Dart_WeakPersistentHandle, int)>();

  /// Allocates a finalizable handle for an object.
  ///
  /// This handle has the lifetime of the current isolate group unless the object
  /// pointed to by the handle is garbage collected, in this case the VM
  /// automatically deletes the handle after invoking the callback associated
  /// with the handle. The handle can also be explicitly deallocated by
  /// calling Dart_DeleteFinalizableHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the
  /// the peer as argument. The callback can be executed on any thread, will have
  /// an isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.
  /// This gives the embedder the ability to cleanup data associated with the
  /// object and clear out any cached references to the handle. All references to
  /// this handle after the callback will be invalid. It is illegal to call into
  /// the VM with any other Dart_* functions from the callback. If the handle is
  /// deleted before the object becomes unreachable, the callback is never
  /// invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The finalizable handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_FinalizableHandle Dart_NewFinalizableHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewFinalizableHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_FinalizableHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, Dart_HandleFinalizer)>>('Dart_NewFinalizableHandle');
  late final _Dart_NewFinalizableHandle =
      _Dart_NewFinalizableHandlePtr.asFunction<
          Dart_FinalizableHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given finalizable [object] handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// Requires there to be a current isolate.
  void Dart_DeleteFinalizableHandle(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
  ) {
    return _Dart_DeleteFinalizableHandle(
      object,
      strong_ref_to_object,
    );
  }

  late final _Dart_DeleteFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle,
              ffi.Handle)>>('Dart_DeleteFinalizableHandle');
  late final _Dart_DeleteFinalizableHandle = _Dart_DeleteFinalizableHandlePtr
      .asFunction<void Function(Dart_FinalizableHandle, Object)>();

  /// Updates the external memory size for the given finalizable handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// May trigger garbage collection.
  void Dart_UpdateFinalizableExternalSize(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
    int external_allocation_size,
  ) {
    return _Dart_UpdateFinalizableExternalSize(
      object,
      strong_ref_to_object,
      external_allocation_size,
    );
  }

  late final _Dart_UpdateFinalizableExternalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle, ffi.Handle,
              ffi.IntPtr)>>('Dart_UpdateFinalizableExternalSize');
  late final _Dart_UpdateFinalizableExternalSize =
      _Dart_UpdateFinalizableExternalSizePtr.asFunction<
          void Function(Dart_FinalizableHandle, Object, int)>();

  /// Gets the version string for the Dart VM.
  ///
  /// The version of the Dart VM can be accessed without initializing the VM.
  ///
  /// \return The version string for the embedded Dart VM.
  ffi.Pointer<ffi.Char> Dart_VersionString() {
    return _Dart_VersionString();
  }

  late final _Dart_VersionStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_VersionString');
  late final _Dart_VersionString =
      _Dart_VersionStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize Dart_IsolateFlags with correct version and default values.
  void Dart_IsolateFlagsInitialize(
    ffi.Pointer<Dart_IsolateFlags> flags,
  ) {
    return _Dart_IsolateFlagsInitialize(
      flags,
    );
  }

  late final _Dart_IsolateFlagsInitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Dart_IsolateFlags>)>>('Dart_IsolateFlagsInitialize');
  late final _Dart_IsolateFlagsInitialize = _Dart_IsolateFlagsInitializePtr
      .asFunction<void Function(ffi.Pointer<Dart_IsolateFlags>)>();

  /// Initializes the VM.
  ///
  /// \param params A struct containing initialization information. The version
  /// field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  ///
  /// \return NULL if initialization is successful. Returns an error message
  /// otherwise. The caller is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_Initialize(
    ffi.Pointer<Dart_InitializeParams> params,
  ) {
    return _Dart_Initialize(
      params,
    );
  }

  late final _Dart_InitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Dart_InitializeParams>)>>('Dart_Initialize');
  late final _Dart_Initialize = _Dart_InitializePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<Dart_InitializeParams>)>();

  /// Cleanup state in the VM before process termination.
  ///
  /// \return NULL if cleanup is successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This function must not be called on a thread that was created by the VM
  /// itself.
  ffi.Pointer<ffi.Char> Dart_Cleanup() {
    return _Dart_Cleanup();
  }

  late final _Dart_CleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_Cleanup');
  late final _Dart_Cleanup =
      _Dart_CleanupPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Sets command line flags. Should be called before Dart_Initialize.
  ///
  /// \param argc The length of the arguments array.
  /// \param argv An array of arguments.
  ///
  /// \return NULL if successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This call does not store references to the passed in c-strings.
  ffi.Pointer<ffi.Char> Dart_SetVMFlags(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _Dart_SetVMFlags(
      argc,
      argv,
    );
  }

  late final _Dart_SetVMFlagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_SetVMFlags');
  late final _Dart_SetVMFlags = _Dart_SetVMFlagsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns true if the named VM flag is of boolean type, specified, and set to
  /// true.
  ///
  /// \param flag_name The name of the flag without leading punctuation
  /// (example: "enable_asserts").
  bool Dart_IsVMFlagSet(
    ffi.Pointer<ffi.Char> flag_name,
  ) {
    return _Dart_IsVMFlagSet(
      flag_name,
    );
  }

  late final _Dart_IsVMFlagSetPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_IsVMFlagSet');
  late final _Dart_IsVMFlagSet =
      _Dart_IsVMFlagSetPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a new isolate. The new isolate becomes the current isolate.
  ///
  /// A snapshot can be used to restore the VM quickly to a saved state
  /// and is useful for fast startup. If snapshot data is provided, the
  /// isolate will be started using that snapshot data. Requires a core snapshot or
  /// an app snapshot created by Dart_CreateSnapshot or
  /// Dart_CreatePrecompiledSnapshot* from a VM with the same version.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI
  /// that allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param isolate_snapshot_data Buffer containing the snapshot data of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffer must
  /// remain valid until the isolate shuts down.
  /// \param isolate_snapshot_instructions Buffer containing the snapshot
  /// instructions of the isolate or NULL if no snapshot is provided. If
  /// provided, the buffer must remain valid until the isolate shuts down.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroup(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_data,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_instructions,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroup(
      script_uri,
      name,
      isolate_snapshot_data,
      isolate_snapshot_instructions,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupPtr = _lookup<
      ffi.NativeFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_CreateIsolateGroup');
  late final _Dart_CreateIsolateGroup = _Dart_CreateIsolateGroupPtr.asFunction<
      Dart_Isolate Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<Dart_IsolateFlags>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate inside the isolate group of [group_member].
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param group_member An isolate from the same group into which the newly created
  /// isolate should be born into. Other threads may not have entered / enter this
  /// member isolate.
  /// \param name A short name for the isolate for debugging purposes.
  /// \param shutdown_callback A callback to be called when the isolate is being
  /// shutdown (may be NULL).
  /// \param cleanup_callback A callback to be called when the isolate is being
  /// cleaned up (may be NULL).
  /// \param isolate_data The embedder-specific data associated with this isolate.
  /// \param error Set to NULL if creation is successful, set to an error
  /// message otherwise. The caller is responsible for calling free() on the
  /// error message.
  ///
  /// \return The newly created isolate on success, or NULL if isolate creation
  /// failed.
  ///
  /// If successful, the newly created isolate will become the current isolate.
  Dart_Isolate Dart_CreateIsolateInGroup(
    Dart_Isolate group_member,
    ffi.Pointer<ffi.Char> name,
    Dart_IsolateShutdownCallback shutdown_callback,
    Dart_IsolateCleanupCallback cleanup_callback,
    ffi.Pointer<ffi.Void> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateInGroup(
      group_member,
      name,
      shutdown_callback,
      cleanup_callback,
      child_isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateInGroupPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  Dart_Isolate,
                  ffi.Pointer<ffi.Char>,
                  Dart_IsolateShutdownCallback,
                  Dart_IsolateCleanupCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateInGroup');
  late final _Dart_CreateIsolateInGroup =
      _Dart_CreateIsolateInGroupPtr.asFunction<
          Dart_Isolate Function(
              Dart_Isolate,
              ffi.Pointer<ffi.Char>,
              Dart_IsolateShutdownCallback,
              Dart_IsolateCleanupCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate from a Dart Kernel file. The new isolate
  /// becomes the current isolate.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a
  /// child isolate is created by Isolate.spawn. The embedder should use a URI that
  /// allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param kernel_buffer A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  /// \param kernel_buffer_size The size of `kernel_buffer`.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroupFromKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroupFromKernel(
      script_uri,
      name,
      kernel_buffer,
      kernel_buffer_size,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupFromKernelPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.IntPtr,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateGroupFromKernel');
  late final _Dart_CreateIsolateGroupFromKernel =
      _Dart_CreateIsolateGroupFromKernelPtr.asFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Shuts down the current isolate. After this call, the current isolate is NULL.
  /// Any current scopes created by Dart_EnterScope will be exited. Invokes the
  /// shutdown callback and any callbacks of remaining weak persistent handles.
  ///
  /// Requires there to be a current isolate.
  void Dart_ShutdownIsolate() {
    return _Dart_ShutdownIsolate();
  }

  late final _Dart_ShutdownIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ShutdownIsolate');
  late final _Dart_ShutdownIsolate =
      _Dart_ShutdownIsolatePtr.asFunction<void Function()>();

  /// Returns the current isolate. Will return NULL if there is no
  /// current isolate.
  Dart_Isolate Dart_CurrentIsolate() {
    return _Dart_CurrentIsolate();
  }

  late final _Dart_CurrentIsolatePtr =
      _lookup<ffi.NativeFunction<Dart_Isolate Function()>>(
          'Dart_CurrentIsolate');
  late final _Dart_CurrentIsolate =
      _Dart_CurrentIsolatePtr.asFunction<Dart_Isolate Function()>();

  /// Returns the callback data associated with the current isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateData() {
    return _Dart_CurrentIsolateData();
  }

  late final _Dart_CurrentIsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateData');
  late final _Dart_CurrentIsolateData = _Dart_CurrentIsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function()>();

  /// Returns the callback data associated with the given isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_IsolateData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateData(
      isolate,
    );
  }

  late final _Dart_IsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateData');
  late final _Dart_IsolateData = _Dart_IsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the current isolate group. Will return NULL if there is no
  /// current isolate group.
  Dart_IsolateGroup Dart_CurrentIsolateGroup() {
    return _Dart_CurrentIsolateGroup();
  }

  late final _Dart_CurrentIsolateGroupPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroup Function()>>(
          'Dart_CurrentIsolateGroup');
  late final _Dart_CurrentIsolateGroup =
      _Dart_CurrentIsolateGroupPtr.asFunction<Dart_IsolateGroup Function()>();

  /// Returns the callback data associated with the current isolate group. This
  /// data was passed to the isolate group when it was created.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateGroupData() {
    return _Dart_CurrentIsolateGroupData();
  }

  late final _Dart_CurrentIsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateGroupData');
  late final _Dart_CurrentIsolateGroupData = _Dart_CurrentIsolateGroupDataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  int Dart_CurrentIsolateGroupId() {
    return _Dart_CurrentIsolateGroupId();
  }

  late final _Dart_CurrentIsolateGroupIdPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroupId Function()>>(
          'Dart_CurrentIsolateGroupId');
  late final _Dart_CurrentIsolateGroupId =
      _Dart_CurrentIsolateGroupIdPtr.asFunction<int Function()>();

  /// Returns the callback data associated with the specified isolate group. This
  /// data was passed to the isolate when it was created.
  /// The embedder is responsible for ensuring the consistency of this data
  /// with respect to the lifecycle of an isolate group.
  ffi.Pointer<ffi.Void> Dart_IsolateGroupData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateGroupData(
      isolate,
    );
  }

  late final _Dart_IsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateGroupData');
  late final _Dart_IsolateGroupData = _Dart_IsolateGroupDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  Object Dart_DebugName() {
    return _Dart_DebugName();
  }

  late final _Dart_DebugNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_DebugName');
  late final _Dart_DebugName =
      _Dart_DebugNamePtr.asFunction<Object Function()>();

  /// Returns the ID for an isolate which is used to query the service protocol.
  ///
  /// It is the responsibility of the caller to free the returned ID.
  ffi.Pointer<ffi.Char> Dart_IsolateServiceId(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateServiceId(
      isolate,
    );
  }

  late final _Dart_IsolateServiceIdPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateServiceId');
  late final _Dart_IsolateServiceId = _Dart_IsolateServiceIdPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Enters an isolate. After calling this function,
  /// the current isolate will be set to the provided isolate.
  ///
  /// Requires there to be no current isolate. Multiple threads may not be in
  /// the same isolate at once.
  void Dart_EnterIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_EnterIsolate(
      isolate,
    );
  }

  late final _Dart_EnterIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_EnterIsolate');
  late final _Dart_EnterIsolate =
      _Dart_EnterIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Kills the given isolate.
  ///
  /// This function has the same effect as dart:isolate's
  /// Isolate.kill(priority:immediate).
  /// It can interrupt ordinary Dart code but not native code. If the isolate is
  /// in the middle of a long running native function, the isolate will not be
  /// killed until control returns to Dart.
  ///
  /// Does not require a current isolate. It is safe to kill the current isolate if
  /// there is one.
  void Dart_KillIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_KillIsolate(
      isolate,
    );
  }

  late final _Dart_KillIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_KillIsolate');
  late final _Dart_KillIsolate =
      _Dart_KillIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Notifies the VM that the embedder expects to be idle until |deadline|. The VM
  /// may use this time to perform garbage collection or other tasks to avoid
  /// delays during execution of Dart code in the future.
  ///
  /// |deadline| is measured in microseconds against the system's monotonic time.
  /// This clock can be accessed via Dart_TimelineGetMicros().
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyIdle(
    int deadline,
  ) {
    return _Dart_NotifyIdle(
      deadline,
    );
  }

  late final _Dart_NotifyIdlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'Dart_NotifyIdle');
  late final _Dart_NotifyIdle =
      _Dart_NotifyIdlePtr.asFunction<void Function(int)>();

  /// Notifies the VM that the embedder expects the application's working set has
  /// recently shrunk significantly and is not expected to rise in the near future.
  /// The VM may spend O(heap-size) time performing clean up work.
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyDetach() {
    return _Dart_NotifyDetach();
  }

  late final _Dart_NotifyDetachPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyDetach');
  late final _Dart_NotifyDetach =
      _Dart_NotifyDetachPtr.asFunction<void Function()>();

  /// Notifies the VM that the system is running low on memory.
  ///
  /// Does not require a current isolate. Only valid after calling Dart_Initialize.
  void Dart_NotifyLowMemory() {
    return _Dart_NotifyLowMemory();
  }

  late final _Dart_NotifyLowMemoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyLowMemory');
  late final _Dart_NotifyLowMemory =
      _Dart_NotifyLowMemoryPtr.asFunction<void Function()>();

  /// Set the desired performance trade-off.
  ///
  /// Requires a current isolate.
  ///
  /// Returns the previous performance mode.
  int Dart_SetPerformanceMode(
    int mode,
  ) {
    return _Dart_SetPerformanceMode(
      mode,
    );
  }

  late final _Dart_SetPerformanceModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'Dart_SetPerformanceMode');
  late final _Dart_SetPerformanceMode =
      _Dart_SetPerformanceModePtr.asFunction<int Function(int)>();

  /// Starts the CPU sampling profiler.
  void Dart_StartProfiling() {
    return _Dart_StartProfiling();
  }

  late final _Dart_StartProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StartProfiling');
  late final _Dart_StartProfiling =
      _Dart_StartProfilingPtr.asFunction<void Function()>();

  /// Stops the CPU sampling profiler.
  ///
  /// Note that some profile samples might still be taken after this fucntion
  /// returns due to the asynchronous nature of the implementation on some
  /// platforms.
  void Dart_StopProfiling() {
    return _Dart_StopProfiling();
  }

  late final _Dart_StopProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StopProfiling');
  late final _Dart_StopProfiling =
      _Dart_StopProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should not be profiled until a
  /// matching call to Dart_ThreadEnableProfiling is made.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  /// This function should be used when an embedder knows a thread is about
  /// to make a blocking call and wants to avoid unnecessary interrupts by
  /// the profiler.
  void Dart_ThreadDisableProfiling() {
    return _Dart_ThreadDisableProfiling();
  }

  late final _Dart_ThreadDisableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadDisableProfiling');
  late final _Dart_ThreadDisableProfiling =
      _Dart_ThreadDisableProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should be profiled.
  ///
  /// NOTE: It is only legal to call this function *after* calling
  /// Dart_ThreadDisableProfiling.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  void Dart_ThreadEnableProfiling() {
    return _Dart_ThreadEnableProfiling();
  }

  late final _Dart_ThreadEnableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadEnableProfiling');
  late final _Dart_ThreadEnableProfiling =
      _Dart_ThreadEnableProfilingPtr.asFunction<void Function()>();

  /// Register symbol information for the Dart VM's profiler and crash dumps.
  ///
  /// This consumes the output of //topaz/runtime/dart/profiler_symbols, which
  /// should be treated as opaque.
  void Dart_AddSymbols(
    ffi.Pointer<ffi.Char> dso_name,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_size,
  ) {
    return _Dart_AddSymbols(
      dso_name,
      buffer,
      buffer_size,
    );
  }

  late final _Dart_AddSymbolsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_AddSymbols');
  late final _Dart_AddSymbols = _Dart_AddSymbolsPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)>();

  /// Exits an isolate. After this call, Dart_CurrentIsolate will
  /// return NULL.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitIsolate() {
    return _Dart_ExitIsolate();
  }

  late final _Dart_ExitIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitIsolate');
  late final _Dart_ExitIsolate =
      _Dart_ExitIsolatePtr.asFunction<void Function()>();

  /// Creates a full snapshot of the current isolate heap.
  ///
  /// A full snapshot is a compact representation of the dart vm isolate heap
  /// and dart isolate heap states. These snapshots are used to initialize
  /// the vm isolate on startup and fast initialization of an isolate.
  /// A Snapshot of the heap is created before any dart code has executed.
  ///
  /// Requires there to be a current isolate. Not available in the precompiled
  /// runtime (check Dart_IsPrecompiledRuntime).
  ///
  /// \param vm_snapshot_data_buffer Returns a pointer to a buffer containing the
  /// vm snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param vm_snapshot_data_size Returns the size of vm_snapshot_data_buffer.
  /// \param isolate_snapshot_data_buffer Returns a pointer to a buffer containing
  /// the isolate snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param isolate_snapshot_data_size Returns the size of
  /// isolate_snapshot_data_buffer.
  /// \param is_core Create a snapshot containing core libraries.
  /// Such snapshot should be agnostic to null safety mode.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateSnapshot(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    bool is_core,
  ) {
    return _Dart_CreateSnapshot(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      is_core,
    );
  }

  late final _Dart_CreateSnapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Bool)>>('Dart_CreateSnapshot');
  late final _Dart_CreateSnapshot = _Dart_CreateSnapshotPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          bool)>();

  /// Returns whether the buffer contains a kernel file.
  ///
  /// \param buffer Pointer to a buffer that might contain a kernel binary.
  /// \param buffer_size Size of the buffer.
  ///
  /// \return Whether the buffer contains a kernel binary (full or partial).
  bool Dart_IsKernel(
    ffi.Pointer<ffi.Uint8> buffer,
    int buffer_size,
  ) {
    return _Dart_IsKernel(
      buffer,
      buffer_size,
    );
  }

  late final _Dart_IsKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_IsKernel');
  late final _Dart_IsKernel = _Dart_IsKernelPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Make isolate runnable.
  ///
  /// When isolates are spawned, this function is used to indicate that
  /// the creation and initialization (including script loading) of the
  /// isolate is complete and the isolate can start.
  /// This function expects there to be no current isolate.
  ///
  /// \param isolate The isolate to be made runnable.
  ///
  /// \return NULL if successful. Returns an error message otherwise. The caller
  /// is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_IsolateMakeRunnable(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateMakeRunnable(
      isolate,
    );
  }

  late final _Dart_IsolateMakeRunnablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateMakeRunnable');
  late final _Dart_IsolateMakeRunnable = _Dart_IsolateMakeRunnablePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Allows embedders to provide a custom wakeup mechanism for the delivery of
  /// inter-isolate messages. This setting only applies to the current isolate.
  ///
  /// This mechanism is optional: if not provided, the isolate will be scheduled on
  /// a VM-managed thread pool. An embedder should provide this callback if it
  /// wants to run an isolate on a specific thread or to interleave handling of
  /// inter-isolate messages with other event sources.
  ///
  /// Most embedders will only call this function once, before isolate
  /// execution begins. If this function is called after isolate
  /// execution begins, the embedder is responsible for threading issues.
  void Dart_SetMessageNotifyCallback(
    Dart_MessageNotifyCallback message_notify_callback,
  ) {
    return _Dart_SetMessageNotifyCallback(
      message_notify_callback,
    );
  }

  late final _Dart_SetMessageNotifyCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Dart_MessageNotifyCallback)>>(
      'Dart_SetMessageNotifyCallback');
  late final _Dart_SetMessageNotifyCallback = _Dart_SetMessageNotifyCallbackPtr
      .asFunction<void Function(Dart_MessageNotifyCallback)>();

  /// Query the current message notify callback for the isolate.
  ///
  /// \return The current message notify callback for the isolate.
  Dart_MessageNotifyCallback Dart_GetMessageNotifyCallback() {
    return _Dart_GetMessageNotifyCallback();
  }

  late final _Dart_GetMessageNotifyCallbackPtr =
      _lookup<ffi.NativeFunction<Dart_MessageNotifyCallback Function()>>(
          'Dart_GetMessageNotifyCallback');
  late final _Dart_GetMessageNotifyCallback = _Dart_GetMessageNotifyCallbackPtr
      .asFunction<Dart_MessageNotifyCallback Function()>();

  /// If the VM flag `--pause-isolates-on-start` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on start was requested.
  bool Dart_ShouldPauseOnStart() {
    return _Dart_ShouldPauseOnStart();
  }

  late final _Dart_ShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnStart');
  late final _Dart_ShouldPauseOnStart =
      _Dart_ShouldPauseOnStartPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-start` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on start?
  ///
  /// NOTE: This must be called before Dart_IsolateMakeRunnable.
  void Dart_SetShouldPauseOnStart(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnStart(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnStart');
  late final _Dart_SetShouldPauseOnStart =
      _Dart_SetShouldPauseOnStartPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on start?
  ///
  /// \return A boolean value indicating if the isolate is paused on start.
  bool Dart_IsPausedOnStart() {
    return _Dart_IsPausedOnStart();
  }

  late final _Dart_IsPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnStart');
  late final _Dart_IsPausedOnStart =
      _Dart_IsPausedOnStartPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on start and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on start?
  void Dart_SetPausedOnStart(
    bool paused,
  ) {
    return _Dart_SetPausedOnStart(
      paused,
    );
  }

  late final _Dart_SetPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnStart');
  late final _Dart_SetPausedOnStart =
      _Dart_SetPausedOnStartPtr.asFunction<void Function(bool)>();

  /// If the VM flag `--pause-isolates-on-exit` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on exit was requested.
  bool Dart_ShouldPauseOnExit() {
    return _Dart_ShouldPauseOnExit();
  }

  late final _Dart_ShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnExit');
  late final _Dart_ShouldPauseOnExit =
      _Dart_ShouldPauseOnExitPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-exit` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on exit?
  void Dart_SetShouldPauseOnExit(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnExit(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnExit');
  late final _Dart_SetShouldPauseOnExit =
      _Dart_SetShouldPauseOnExitPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on exit?
  ///
  /// \return A boolean value indicating if the isolate is paused on exit.
  bool Dart_IsPausedOnExit() {
    return _Dart_IsPausedOnExit();
  }

  late final _Dart_IsPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnExit');
  late final _Dart_IsPausedOnExit =
      _Dart_IsPausedOnExitPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on exit and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on exit?
  void Dart_SetPausedOnExit(
    bool paused,
  ) {
    return _Dart_SetPausedOnExit(
      paused,
    );
  }

  late final _Dart_SetPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnExit');
  late final _Dart_SetPausedOnExit =
      _Dart_SetPausedOnExitPtr.asFunction<void Function(bool)>();

  /// Called when the embedder has caught a top level unhandled exception error
  /// in the current isolate.
  ///
  /// NOTE: It is illegal to call this twice on the same isolate without first
  /// clearing the sticky error to null.
  ///
  /// \param error The unhandled exception error.
  void Dart_SetStickyError(
    Object error,
  ) {
    return _Dart_SetStickyError(
      error,
    );
  }

  late final _Dart_SetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_SetStickyError');
  late final _Dart_SetStickyError =
      _Dart_SetStickyErrorPtr.asFunction<void Function(Object)>();

  /// Does the current isolate have a sticky error?
  bool Dart_HasStickyError() {
    return _Dart_HasStickyError();
  }

  late final _Dart_HasStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasStickyError');
  late final _Dart_HasStickyError =
      _Dart_HasStickyErrorPtr.asFunction<bool Function()>();

  /// Gets the sticky error for the current isolate.
  ///
  /// \return A handle to the sticky error object or null.
  Object Dart_GetStickyError() {
    return _Dart_GetStickyError();
  }

  late final _Dart_GetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_GetStickyError');
  late final _Dart_GetStickyError =
      _Dart_GetStickyErrorPtr.asFunction<Object Function()>();

  /// Handles the next pending message for the current isolate.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_HandleMessage() {
    return _Dart_HandleMessage();
  }

  late final _Dart_HandleMessagePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_HandleMessage');
  late final _Dart_HandleMessage =
      _Dart_HandleMessagePtr.asFunction<Object Function()>();

  /// Drains the microtask queue, then blocks the calling thread until the current
  /// isolate receives a message, then handles all messages.
  ///
  /// \param timeout_millis When non-zero, the call returns after the indicated
  /// number of milliseconds even if no message was received.
  /// \return A valid handle if no error occurs, otherwise an error handle.
  Object Dart_WaitForEvent(
    int timeout_millis,
  ) {
    return _Dart_WaitForEvent(
      timeout_millis,
    );
  }

  late final _Dart_WaitForEventPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_WaitForEvent');
  late final _Dart_WaitForEvent =
      _Dart_WaitForEventPtr.asFunction<Object Function(int)>();

  /// Handles any pending messages for the vm service for the current
  /// isolate.
  ///
  /// This function may be used by an embedder at a breakpoint to avoid
  /// pausing the vm service.
  ///
  /// This function can indirectly cause the message notify callback to
  /// be called.
  ///
  /// \return true if the vm service requests the program resume
  /// execution, false otherwise
  bool Dart_HandleServiceMessages() {
    return _Dart_HandleServiceMessages();
  }

  late final _Dart_HandleServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HandleServiceMessages');
  late final _Dart_HandleServiceMessages =
      _Dart_HandleServiceMessagesPtr.asFunction<bool Function()>();

  /// Does the current isolate have pending service messages?
  ///
  /// \return true if the isolate has pending service messages, false otherwise.
  bool Dart_HasServiceMessages() {
    return _Dart_HasServiceMessages();
  }

  late final _Dart_HasServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HasServiceMessages');
  late final _Dart_HasServiceMessages =
      _Dart_HasServiceMessagesPtr.asFunction<bool Function()>();

  /// Processes any incoming messages for the current isolate.
  ///
  /// This function may only be used when the embedder has not provided
  /// an alternate message delivery mechanism with
  /// Dart_SetMessageCallbacks. It is provided for convenience.
  ///
  /// This function waits for incoming messages for the current
  /// isolate. As new messages arrive, they are handled using
  /// Dart_HandleMessage. The routine exits when all ports to the
  /// current isolate are closed.
  ///
  /// \return A valid handle if the run loop exited successfully.  If an
  /// exception or other error occurs while processing messages, an
  /// error handle is returned.
  Object Dart_RunLoop() {
    return _Dart_RunLoop();
  }

  late final _Dart_RunLoopPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RunLoop');
  late final _Dart_RunLoop = _Dart_RunLoopPtr.asFunction<Object Function()>();

  /// Lets the VM run message processing for the isolate.
  ///
  /// This function expects there to a current isolate and the current isolate
  /// must not have an active api scope. The VM will take care of making the
  /// isolate runnable (if not already), handles its message loop and will take
  /// care of shutting the isolate down once it's done.
  ///
  /// \param errors_are_fatal Whether uncaught errors should be fatal.
  /// \param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).
  /// \param on_exit_port A port to notify on exit (or ILLEGAL_PORT).
  /// \param error A non-NULL pointer which will hold an error message if the call
  /// fails. The error has to be free()ed by the caller.
  ///
  /// \return If successful the VM takes owernship of the isolate and takes care
  /// of its message loop. If not successful the caller retains owernship of the
  /// isolate.
  bool Dart_RunLoopAsync(
    bool errors_are_fatal,
    int on_error_port,
    int on_exit_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_RunLoopAsync(
      errors_are_fatal,
      on_error_port,
      on_exit_port,
      error,
    );
  }

  late final _Dart_RunLoopAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Bool, Dart_Port, Dart_Port,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_RunLoopAsync');
  late final _Dart_RunLoopAsync = _Dart_RunLoopAsyncPtr.asFunction<
      bool Function(bool, int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets the main port id for the current isolate.
  int Dart_GetMainPortId() {
    return _Dart_GetMainPortId();
  }

  late final _Dart_GetMainPortIdPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_GetMainPortId');
  late final _Dart_GetMainPortId =
      _Dart_GetMainPortIdPtr.asFunction<int Function()>();

  /// Does the current isolate have live ReceivePorts?
  ///
  /// A ReceivePort is live when it has not been closed.
  bool Dart_HasLivePorts() {
    return _Dart_HasLivePorts();
  }

  late final _Dart_HasLivePortsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasLivePorts');
  late final _Dart_HasLivePorts =
      _Dart_HasLivePortsPtr.asFunction<bool Function()>();

  /// Posts a message for some isolate. The message is a serialized
  /// object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// For posting messages outside of an isolate see \ref Dart_PostCObject.
  ///
  /// \param port_id The destination port.
  /// \param object An object from the current isolate.
  ///
  /// \return True if the message was posted.
  bool Dart_Post(
    int port_id,
    Object object,
  ) {
    return _Dart_Post(
      port_id,
      object,
    );
  }

  late final _Dart_PostPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Handle)>>(
          'Dart_Post');
  late final _Dart_Post =
      _Dart_PostPtr.asFunction<bool Function(int, Object)>();

  /// Returns a new SendPort with the provided port id.
  ///
  /// \param port_id The destination port.
  ///
  /// \return A new SendPort if no errors occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewSendPort(
    int port_id,
  ) {
    return _Dart_NewSendPort(
      port_id,
    );
  }

  late final _Dart_NewSendPortPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_Port)>>(
          'Dart_NewSendPort');
  late final _Dart_NewSendPort =
      _Dart_NewSendPortPtr.asFunction<Object Function(int)>();

  /// Gets the SendPort id for the provided SendPort.
  /// \param port A SendPort object whose id is desired.
  /// \param port_id Returns the id of the SendPort.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_SendPortGetId(
    Object port,
    ffi.Pointer<Dart_Port> port_id,
  ) {
    return _Dart_SendPortGetId(
      port,
      port_id,
    );
  }

  late final _Dart_SendPortGetIdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<Dart_Port>)>>('Dart_SendPortGetId');
  late final _Dart_SendPortGetId = _Dart_SendPortGetIdPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_Port>)>();

  /// Enters a new scope.
  ///
  /// All new local handles will be created in this scope. Additionally,
  /// some functions may return "scope allocated" memory which is only
  /// valid within this scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_EnterScope() {
    return _Dart_EnterScope();
  }

  late final _Dart_EnterScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_EnterScope');
  late final _Dart_EnterScope =
      _Dart_EnterScopePtr.asFunction<void Function()>();

  /// Exits a scope.
  ///
  /// The previous scope (if any) becomes the current scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitScope() {
    return _Dart_ExitScope();
  }

  late final _Dart_ExitScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitScope');
  late final _Dart_ExitScope = _Dart_ExitScopePtr.asFunction<void Function()>();

  /// The Dart VM uses "zone allocation" for temporary structures. Zones
  /// support very fast allocation of small chunks of memory. The chunks
  /// cannot be deallocated individually, but instead zones support
  /// deallocating all chunks in one fast operation.
  ///
  /// This function makes it possible for the embedder to allocate
  /// temporary data in the VMs zone allocator.
  ///
  /// Zone allocation is possible:
  /// 1. when inside a scope where local handles can be allocated
  /// 2. when processing a message from a native port in a native port
  /// handler
  ///
  /// All the memory allocated this way will be reclaimed either on the
  /// next call to Dart_ExitScope or when the native port handler exits.
  ///
  /// \param size Size of the memory to allocate.
  ///
  /// \return A pointer to the allocated memory. NULL if allocation
  /// failed. Failure might due to is no current VM zone.
  ffi.Pointer<ffi.Uint8> Dart_ScopeAllocate(
    int size,
  ) {
    return _Dart_ScopeAllocate(
      size,
    );
  }

  late final _Dart_ScopeAllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr)>>(
          'Dart_ScopeAllocate');
  late final _Dart_ScopeAllocate =
      _Dart_ScopeAllocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  /// Returns the null object.
  ///
  /// \return A handle to the null object.
  Object Dart_Null() {
    return _Dart_Null();
  }

  late final _Dart_NullPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Null');
  late final _Dart_Null = _Dart_NullPtr.asFunction<Object Function()>();

  /// Is this object null?
  bool Dart_IsNull(
    Object object,
  ) {
    return _Dart_IsNull(
      object,
    );
  }

  late final _Dart_IsNullPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsNull');
  late final _Dart_IsNull = _Dart_IsNullPtr.asFunction<bool Function(Object)>();

  /// Returns the empty string object.
  ///
  /// \return A handle to the empty string object.
  Object Dart_EmptyString() {
    return _Dart_EmptyString();
  }

  late final _Dart_EmptyStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_EmptyString');
  late final _Dart_EmptyString =
      _Dart_EmptyStringPtr.asFunction<Object Function()>();

  /// Returns types that are not classes, and which therefore cannot be looked up
  /// as library members by Dart_GetType.
  ///
  /// \return A handle to the dynamic, void or Never type.
  Object Dart_TypeDynamic() {
    return _Dart_TypeDynamic();
  }

  late final _Dart_TypeDynamicPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeDynamic');
  late final _Dart_TypeDynamic =
      _Dart_TypeDynamicPtr.asFunction<Object Function()>();

  Object Dart_TypeVoid() {
    return _Dart_TypeVoid();
  }

  late final _Dart_TypeVoidPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeVoid');
  late final _Dart_TypeVoid = _Dart_TypeVoidPtr.asFunction<Object Function()>();

  Object Dart_TypeNever() {
    return _Dart_TypeNever();
  }

  late final _Dart_TypeNeverPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeNever');
  late final _Dart_TypeNever =
      _Dart_TypeNeverPtr.asFunction<Object Function()>();

  /// Checks if the two objects are equal.
  ///
  /// The result of the comparison is returned through the 'equal'
  /// parameter. The return value itself is used to indicate success or
  /// failure, not equality.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  /// \param equal Returns the result of the equality comparison.
  ///
  /// \return A valid handle if no error occurs during the comparison.
  Object Dart_ObjectEquals(
    Object obj1,
    Object obj2,
    ffi.Pointer<ffi.Bool> equal,
  ) {
    return _Dart_ObjectEquals(
      obj1,
      obj2,
      equal,
    );
  }

  late final _Dart_ObjectEqualsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectEquals');
  late final _Dart_ObjectEquals = _Dart_ObjectEqualsPtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object an instance of some type?
  ///
  /// The result of the test is returned through the 'instanceof' parameter.
  /// The return value itself is used to indicate success or failure.
  ///
  /// \param object An object.
  /// \param type A type.
  /// \param instanceof Return true if 'object' is an instance of type 'type'.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ObjectIsType(
    Object object,
    Object type,
    ffi.Pointer<ffi.Bool> instanceof,
  ) {
    return _Dart_ObjectIsType(
      object,
      type,
      instanceof,
    );
  }

  late final _Dart_ObjectIsTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectIsType');
  late final _Dart_ObjectIsType = _Dart_ObjectIsTypePtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Query object type.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is of the specified type.
  bool Dart_IsInstance(
    Object object,
  ) {
    return _Dart_IsInstance(
      object,
    );
  }

  late final _Dart_IsInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInstance');
  late final _Dart_IsInstance =
      _Dart_IsInstancePtr.asFunction<bool Function(Object)>();

  bool Dart_IsNumber(
    Object object,
  ) {
    return _Dart_IsNumber(
      object,
    );
  }

  late final _Dart_IsNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsNumber');
  late final _Dart_IsNumber =
      _Dart_IsNumberPtr.asFunction<bool Function(Object)>();

  bool Dart_IsInteger(
    Object object,
  ) {
    return _Dart_IsInteger(
      object,
    );
  }

  late final _Dart_IsIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInteger');
  late final _Dart_IsInteger =
      _Dart_IsIntegerPtr.asFunction<bool Function(Object)>();

  bool Dart_IsDouble(
    Object object,
  ) {
    return _Dart_IsDouble(
      object,
    );
  }

  late final _Dart_IsDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsDouble');
  late final _Dart_IsDouble =
      _Dart_IsDoublePtr.asFunction<bool Function(Object)>();

  bool Dart_IsBoolean(
    Object object,
  ) {
    return _Dart_IsBoolean(
      object,
    );
  }

  late final _Dart_IsBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsBoolean');
  late final _Dart_IsBoolean =
      _Dart_IsBooleanPtr.asFunction<bool Function(Object)>();

  bool Dart_IsString(
    Object object,
  ) {
    return _Dart_IsString(
      object,
    );
  }

  late final _Dart_IsStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsString');
  late final _Dart_IsString =
      _Dart_IsStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsStringLatin1(
    Object object,
  ) {
    return _Dart_IsStringLatin1(
      object,
    );
  }

  late final _Dart_IsStringLatin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsStringLatin1');
  late final _Dart_IsStringLatin1 =
      _Dart_IsStringLatin1Ptr.asFunction<bool Function(Object)>();

  bool Dart_IsExternalString(
    Object object,
  ) {
    return _Dart_IsExternalString(
      object,
    );
  }

  late final _Dart_IsExternalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsExternalString');
  late final _Dart_IsExternalString =
      _Dart_IsExternalStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsList(
    Object object,
  ) {
    return _Dart_IsList(
      object,
    );
  }

  late final _Dart_IsListPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsList');
  late final _Dart_IsList = _Dart_IsListPtr.asFunction<bool Function(Object)>();

  bool Dart_IsMap(
    Object object,
  ) {
    return _Dart_IsMap(
      object,
    );
  }

  late final _Dart_IsMapPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsMap');
  late final _Dart_IsMap = _Dart_IsMapPtr.asFunction<bool Function(Object)>();

  bool Dart_IsLibrary(
    Object object,
  ) {
    return _Dart_IsLibrary(
      object,
    );
  }

  late final _Dart_IsLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsLibrary');
  late final _Dart_IsLibrary =
      _Dart_IsLibraryPtr.asFunction<bool Function(Object)>();

  bool Dart_IsType(
    Object handle,
  ) {
    return _Dart_IsType(
      handle,
    );
  }

  late final _Dart_IsTypePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsType');
  late final _Dart_IsType = _Dart_IsTypePtr.asFunction<bool Function(Object)>();

  bool Dart_IsFunction(
    Object handle,
  ) {
    return _Dart_IsFunction(
      handle,
    );
  }

  late final _Dart_IsFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFunction');
  late final _Dart_IsFunction =
      _Dart_IsFunctionPtr.asFunction<bool Function(Object)>();

  bool Dart_IsVariable(
    Object handle,
  ) {
    return _Dart_IsVariable(
      handle,
    );
  }

  late final _Dart_IsVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsVariable');
  late final _Dart_IsVariable =
      _Dart_IsVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypeVariable(
    Object handle,
  ) {
    return _Dart_IsTypeVariable(
      handle,
    );
  }

  late final _Dart_IsTypeVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypeVariable');
  late final _Dart_IsTypeVariable =
      _Dart_IsTypeVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsClosure(
    Object object,
  ) {
    return _Dart_IsClosure(
      object,
    );
  }

  late final _Dart_IsClosurePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsClosure');
  late final _Dart_IsClosure =
      _Dart_IsClosurePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypedData(
    Object object,
  ) {
    return _Dart_IsTypedData(
      object,
    );
  }

  late final _Dart_IsTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypedData');
  late final _Dart_IsTypedData =
      _Dart_IsTypedDataPtr.asFunction<bool Function(Object)>();

  bool Dart_IsByteBuffer(
    Object object,
  ) {
    return _Dart_IsByteBuffer(
      object,
    );
  }

  late final _Dart_IsByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsByteBuffer');
  late final _Dart_IsByteBuffer =
      _Dart_IsByteBufferPtr.asFunction<bool Function(Object)>();

  bool Dart_IsFuture(
    Object object,
  ) {
    return _Dart_IsFuture(
      object,
    );
  }

  late final _Dart_IsFuturePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFuture');
  late final _Dart_IsFuture =
      _Dart_IsFuturePtr.asFunction<bool Function(Object)>();

  /// Gets the type of a Dart language object.
  ///
  /// \param instance Some Dart object.
  ///
  /// \return If no error occurs, the type is returned. Otherwise an
  /// error handle is returned.
  Object Dart_InstanceGetType(
    Object instance,
  ) {
    return _Dart_InstanceGetType(
      instance,
    );
  }

  late final _Dart_InstanceGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_InstanceGetType');
  late final _Dart_InstanceGetType =
      _Dart_InstanceGetTypePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided class type.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_ClassName(
    Object cls_type,
  ) {
    return _Dart_ClassName(
      cls_type,
    );
  }

  late final _Dart_ClassNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassName');
  late final _Dart_ClassName =
      _Dart_ClassNamePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided function or method.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_FunctionName(
    Object function,
  ) {
    return _Dart_FunctionName(
      function,
    );
  }

  late final _Dart_FunctionNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionName');
  late final _Dart_FunctionName =
      _Dart_FunctionNamePtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the owner of a function.
  ///
  /// The owner of an instance method or a static method is its defining
  /// class. The owner of a top-level function is its defining
  /// library. The owner of the function of a non-implicit closure is the
  /// function of the method or closure that defines the non-implicit
  /// closure.
  ///
  /// \return A valid handle to the owner of the function, or an error
  /// handle if the argument is not a valid handle to a function.
  Object Dart_FunctionOwner(
    Object function,
  ) {
    return _Dart_FunctionOwner(
      function,
    );
  }

  late final _Dart_FunctionOwnerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionOwner');
  late final _Dart_FunctionOwner =
      _Dart_FunctionOwnerPtr.asFunction<Object Function(Object)>();

  /// Determines whether a function handle referes to a static function
  /// of method.
  ///
  /// For the purposes of the embedding API, a top-level function is
  /// implicitly declared static.
  ///
  /// \param function A handle to a function or method declaration.
  /// \param is_static Returns whether the function or method is declared static.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_FunctionIsStatic(
    Object function,
    ffi.Pointer<ffi.Bool> is_static,
  ) {
    return _Dart_FunctionIsStatic(
      function,
      is_static,
    );
  }

  late final _Dart_FunctionIsStaticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_FunctionIsStatic');
  late final _Dart_FunctionIsStatic = _Dart_FunctionIsStaticPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object a closure resulting from a tear-off (closurized method)?
  ///
  /// Returns true for closures produced when an ordinary method is accessed
  /// through a getter call. Returns false otherwise, in particular for closures
  /// produced from local function declarations.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is a tear-off.
  bool Dart_IsTearOff(
    Object object,
  ) {
    return _Dart_IsTearOff(
      object,
    );
  }

  late final _Dart_IsTearOffPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTearOff');
  late final _Dart_IsTearOff =
      _Dart_IsTearOffPtr.asFunction<bool Function(Object)>();

  /// Retrieves the function of a closure.
  ///
  /// \return A handle to the function of the closure, or an error handle if the
  /// argument is not a closure.
  Object Dart_ClosureFunction(
    Object closure,
  ) {
    return _Dart_ClosureFunction(
      closure,
    );
  }

  late final _Dart_ClosureFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClosureFunction');
  late final _Dart_ClosureFunction =
      _Dart_ClosureFunctionPtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the library which contains class.
  ///
  /// \return A valid handle to the library with owns class, null if the class
  /// has no library or an error handle if the argument is not a valid handle
  /// to a class type.
  Object Dart_ClassLibrary(
    Object cls_type,
  ) {
    return _Dart_ClassLibrary(
      cls_type,
    );
  }

  late final _Dart_ClassLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassLibrary');
  late final _Dart_ClassLibrary =
      _Dart_ClassLibraryPtr.asFunction<Object Function(Object)>();

  /// Does this Integer fit into a 64-bit signed integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit signed integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoInt64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoInt64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoInt64');
  late final _Dart_IntegerFitsIntoInt64 = _Dart_IntegerFitsIntoInt64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Does this Integer fit into a 64-bit unsigned integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit unsigned integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoUint64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoUint64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoUint64');
  late final _Dart_IntegerFitsIntoUint64 = _Dart_IntegerFitsIntoUint64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewInteger(
    int value,
  ) {
    return _Dart_NewInteger(
      value,
    );
  }

  late final _Dart_NewIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_NewInteger');
  late final _Dart_NewInteger =
      _Dart_NewIntegerPtr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The unsigned value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromUint64(
    int value,
  ) {
    return _Dart_NewIntegerFromUint64(
      value,
    );
  }

  late final _Dart_NewIntegerFromUint64Ptr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Uint64)>>(
          'Dart_NewIntegerFromUint64');
  late final _Dart_NewIntegerFromUint64 =
      _Dart_NewIntegerFromUint64Ptr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer represented as a C string
  /// containing a hexadecimal number.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromHexCString(
    ffi.Pointer<ffi.Char> value,
  ) {
    return _Dart_NewIntegerFromHexCString(
      value,
    );
  }

  late final _Dart_NewIntegerFromHexCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewIntegerFromHexCString');
  late final _Dart_NewIntegerFromHexCString = _Dart_NewIntegerFromHexCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit signed integer, otherwise an error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToInt64(
    Object integer,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_IntegerToInt64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Int64>)>>('Dart_IntegerToInt64');
  late final _Dart_IntegerToInt64 = _Dart_IntegerToInt64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Int64>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit unsigned integer, otherwise an
  /// error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToUint64(
    Object integer,
    ffi.Pointer<ffi.Uint64> value,
  ) {
    return _Dart_IntegerToUint64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Uint64>)>>('Dart_IntegerToUint64');
  late final _Dart_IntegerToUint64 = _Dart_IntegerToUint64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Uint64>)>();

  /// Gets the value of an integer as a hexadecimal C string.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer as a hexadecimal C
  /// string. This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToHexCString(
    Object integer,
    ffi.Pointer<ffi.Pointer<ffi.Char>> value,
  ) {
    return _Dart_IntegerToHexCString(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToHexCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_IntegerToHexCString');
  late final _Dart_IntegerToHexCString =
      _Dart_IntegerToHexCStringPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns a Double with the provided value.
  ///
  /// \param value A double.
  ///
  /// \return The Double object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewDouble(
    double value,
  ) {
    return _Dart_NewDouble(
      value,
    );
  }

  late final _Dart_NewDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Double)>>(
          'Dart_NewDouble');
  late final _Dart_NewDouble =
      _Dart_NewDoublePtr.asFunction<Object Function(double)>();

  /// Gets the value of a Double
  ///
  /// \param double_obj A Double
  /// \param value Returns the value of the Double.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_DoubleValue(
    Object double_obj,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_DoubleValue(
      double_obj,
      value,
    );
  }

  late final _Dart_DoubleValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Double>)>>('Dart_DoubleValue');
  late final _Dart_DoubleValue = _Dart_DoubleValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Double>)>();

  /// Returns a closure of static function 'function_name' in the class 'class_name'
  /// in the exported namespace of specified 'library'.
  ///
  /// \param library Library object
  /// \param cls_type Type object representing a Class
  /// \param function_name Name of the static function in the class
  ///
  /// \return A valid Dart instance if no error occurs during the operation.
  Object Dart_GetStaticMethodClosure(
    Object library1,
    Object cls_type,
    Object function_name,
  ) {
    return _Dart_GetStaticMethodClosure(
      library1,
      cls_type,
      function_name,
    );
  }

  late final _Dart_GetStaticMethodClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Handle)>>('Dart_GetStaticMethodClosure');
  late final _Dart_GetStaticMethodClosure = _Dart_GetStaticMethodClosurePtr
      .asFunction<Object Function(Object, Object, Object)>();

  /// Returns the True object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the True object.
  Object Dart_True() {
    return _Dart_True();
  }

  late final _Dart_TruePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_True');
  late final _Dart_True = _Dart_TruePtr.asFunction<Object Function()>();

  /// Returns the False object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the False object.
  Object Dart_False() {
    return _Dart_False();
  }

  late final _Dart_FalsePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_False');
  late final _Dart_False = _Dart_FalsePtr.asFunction<Object Function()>();

  /// Returns a Boolean with the provided value.
  ///
  /// \param value true or false.
  ///
  /// \return The Boolean object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewBoolean(
    bool value,
  ) {
    return _Dart_NewBoolean(
      value,
    );
  }

  late final _Dart_NewBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_NewBoolean');
  late final _Dart_NewBoolean =
      _Dart_NewBooleanPtr.asFunction<Object Function(bool)>();

  /// Gets the value of a Boolean
  ///
  /// \param boolean_obj A Boolean
  /// \param value Returns the value of the Boolean.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_BooleanValue(
    Object boolean_obj,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_BooleanValue(
      boolean_obj,
      value,
    );
  }

  late final _Dart_BooleanValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_BooleanValue');
  late final _Dart_BooleanValue = _Dart_BooleanValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Gets the length of a String.
  ///
  /// \param str A String.
  /// \param length Returns the length of the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringLength(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringLength(
      str,
      length,
    );
  }

  late final _Dart_StringLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringLength');
  late final _Dart_StringLength = _Dart_StringLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns a String built from the provided C string
  /// (There is an implicit assumption that the C string passed in contains
  /// UTF-8 encoded characters and '\0' is considered as a termination
  /// character).
  ///
  /// \param str A C String
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromCString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _Dart_NewStringFromCString(
      str,
    );
  }

  late final _Dart_NewStringFromCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewStringFromCString');
  late final _Dart_NewStringFromCString = _Dart_NewStringFromCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Returns a String built from an array of UTF-8 encoded characters.
  ///
  /// \param utf8_array An array of UTF-8 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF8(
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF8(
      utf8_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_NewStringFromUTF8');
  late final _Dart_NewStringFromUTF8 = _Dart_NewStringFromUTF8Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns a String built from an array of UTF-16 encoded characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF16(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF16(
      utf16_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>, ffi.IntPtr)>>('Dart_NewStringFromUTF16');
  late final _Dart_NewStringFromUTF16 = _Dart_NewStringFromUTF16Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint16>, int)>();

  /// Returns a String built from an array of UTF-32 encoded characters.
  ///
  /// \param utf32_array An array of UTF-32 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF32(
    ffi.Pointer<ffi.Int32> utf32_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF32(
      utf32_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr)>>('Dart_NewStringFromUTF32');
  late final _Dart_NewStringFromUTF32 = _Dart_NewStringFromUTF32Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Int32>, int)>();

  /// Returns a String which references an external array of
  /// Latin-1 (ISO-8859-1) encoded characters.
  ///
  /// \param latin1_array Array of Latin-1 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalLatin1String(
    ffi.Pointer<ffi.Uint8> latin1_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalLatin1String(
      latin1_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalLatin1StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalLatin1String');
  late final _Dart_NewExternalLatin1String =
      _Dart_NewExternalLatin1StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Returns a String which references an external array of UTF-16 encoded
  /// characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalUTF16String(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalUTF16String(
      utf16_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalUTF16StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalUTF16String');
  late final _Dart_NewExternalUTF16String =
      _Dart_NewExternalUTF16StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint16>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Gets the C string representation of a String.
  /// (It is a sequence of UTF-8 encoded values with a '\0' termination.)
  ///
  /// \param str A string.
  /// \param cstr Returns the String represented as a C string.
  /// This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToCString(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> cstr,
  ) {
    return _Dart_StringToCString(
      str,
      cstr,
    );
  }

  late final _Dart_StringToCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_StringToCString');
  late final _Dart_StringToCString = _Dart_StringToCStringPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets a UTF-8 encoded representation of a String.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need
  /// to preserve unpaired surrogates, use the Dart_StringToUTF16 function.
  ///
  /// \param str A string.
  /// \param utf8_array Returns the String represented as UTF-8 code
  /// units.  This UTF-8 array is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param length Used to return the length of the array which was
  /// actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF8(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> utf8_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF8(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_StringToUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF8');
  late final _Dart_StringToUTF8 = _Dart_StringToUTF8Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the data corresponding to the string object. This function returns
  /// the data only for Latin-1 (ISO-8859-1) string objects. For all other
  /// string objects it returns an error.
  ///
  /// \param str A string.
  /// \param latin1_array An array allocated by the caller, used to return
  /// the string data.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToLatin1(
    Object str,
    ffi.Pointer<ffi.Uint8> latin1_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToLatin1(
      str,
      latin1_array,
      length,
    );
  }

  late final _Dart_StringToLatin1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToLatin1');
  late final _Dart_StringToLatin1 = _Dart_StringToLatin1Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the UTF-16 encoded representation of a string.
  ///
  /// \param str A string.
  /// \param utf16_array An array allocated by the caller, used to return
  /// the array of UTF-16 encoded characters.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF16(
    Object str,
    ffi.Pointer<ffi.Uint16> utf16_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF16(
      str,
      utf16_array,
      length,
    );
  }

  late final _Dart_StringToUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF16');
  late final _Dart_StringToUTF16 = _Dart_StringToUTF16Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the storage size in bytes of a String.
  ///
  /// \param str A String.
  /// \param size Returns the storage size in bytes of the String.
  /// This is the size in bytes needed to store the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringStorageSize(
    Object str,
    ffi.Pointer<ffi.IntPtr> size,
  ) {
    return _Dart_StringStorageSize(
      str,
      size,
    );
  }

  late final _Dart_StringStorageSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringStorageSize');
  late final _Dart_StringStorageSize = _Dart_StringStorageSizePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Retrieves some properties associated with a String.
  /// Properties retrieved are:
  /// - character size of the string (one or two byte)
  /// - length of the string
  /// - peer pointer of string if it is an external string.
  /// \param str A String.
  /// \param char_size Returns the character size of the String.
  /// \param str_len Returns the length of the String.
  /// \param peer Returns the peer pointer associated with the String or 0 if
  /// there is no peer pointer for it.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_StringGetProperties(
    Object str,
    ffi.Pointer<ffi.IntPtr> char_size,
    ffi.Pointer<ffi.IntPtr> str_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_StringGetProperties(
      str,
      char_size,
      str_len,
      peer,
    );
  }

  late final _Dart_StringGetPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_StringGetProperties');
  late final _Dart_StringGetProperties =
      _Dart_StringGetPropertiesPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Returns a List<dynamic> of the desired length.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewList(
    int length,
  ) {
    return _Dart_NewList(
      length,
    );
  }

  late final _Dart_NewListPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_NewList');
  late final _Dart_NewList =
      _Dart_NewListPtr.asFunction<Object Function(int)>();

  /// Returns a List of the desired length with the desired legacy element type.
  ///
  /// \param element_type_id The type of elements of the list.
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns an error
  /// handle.
  Object Dart_NewListOf(
    int element_type_id,
    int length,
  ) {
    return _Dart_NewListOf(
      element_type_id,
      length,
    );
  }

  late final _Dart_NewListOfPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewListOf');
  late final _Dart_NewListOf =
      _Dart_NewListOfPtr.asFunction<Object Function(int, int)>();

  /// Returns a List of the desired length with the desired element type.
  ///
  /// \param element_type Handle to a nullable type object. E.g., from
  /// Dart_GetType or Dart_GetNullableType.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfType(
    Object element_type,
    int length,
  ) {
    return _Dart_NewListOfType(
      element_type,
      length,
    );
  }

  late final _Dart_NewListOfTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_NewListOfType');
  late final _Dart_NewListOfType =
      _Dart_NewListOfTypePtr.asFunction<Object Function(Object, int)>();

  /// Returns a List of the desired length with the desired element type, filled
  /// with the provided object.
  ///
  /// \param element_type Handle to a type object. E.g., from Dart_GetType.
  ///
  /// \param fill_object Handle to an object of type 'element_type' that will be
  /// used to populate the list. This parameter can only be Dart_Null() if the
  /// length of the list is 0 or 'element_type' is a nullable type.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfTypeFilled(
    Object element_type,
    Object fill_object,
    int length,
  ) {
    return _Dart_NewListOfTypeFilled(
      element_type,
      fill_object,
      length,
    );
  }

  late final _Dart_NewListOfTypeFilledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.IntPtr)>>('Dart_NewListOfTypeFilled');
  late final _Dart_NewListOfTypeFilled = _Dart_NewListOfTypeFilledPtr
      .asFunction<Object Function(Object, Object, int)>();

  /// Gets the length of a List.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param length Returns the length of the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListLength(
    Object list,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_ListLength(
      list,
      length,
    );
  }

  late final _Dart_ListLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_ListLength');
  late final _Dart_ListLength = _Dart_ListLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  ///
  /// \return The Object in the List at the specified index if no error
  /// occurs. Otherwise returns an error handle.
  Object Dart_ListGetAt(
    Object list,
    int index,
  ) {
    return _Dart_ListGetAt(
      list,
      index,
    );
  }

  late final _Dart_ListGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_ListGetAt');
  late final _Dart_ListGetAt =
      _Dart_ListGetAtPtr.asFunction<Object Function(Object, int)>();

  /// Gets a range of Objects from a List.
  ///
  /// If any of the requested index values are out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param offset The offset of the first item to get.
  /// \param length The number of items to get.
  /// \param result A pointer to fill with the objects.
  ///
  /// \return Success if no error occurs during the operation.
  Object Dart_ListGetRange(
    Object list,
    int offset,
    int length,
    ffi.Pointer<ffi.Handle> result,
  ) {
    return _Dart_ListGetRange(
      list,
      offset,
      length,
      result,
    );
  }

  late final _Dart_ListGetRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_ListGetRange');
  late final _Dart_ListGetRange = _Dart_ListGetRangePtr.asFunction<
      Object Function(Object, int, int, ffi.Pointer<ffi.Handle>)>();

  /// Sets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  /// \param value The Object to put in the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListSetAt(
    Object list,
    int index,
    Object value,
  ) {
    return _Dart_ListSetAt(
      list,
      index,
      value,
    );
  }

  late final _Dart_ListSetAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.IntPtr, ffi.Handle)>>('Dart_ListSetAt');
  late final _Dart_ListSetAt =
      _Dart_ListSetAtPtr.asFunction<Object Function(Object, int, Object)>();

  /// May generate an unhandled exception error.
  Object Dart_ListGetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListGetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListGetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListGetAsBytes');
  late final _Dart_ListGetAsBytes = _Dart_ListGetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// May generate an unhandled exception error.
  Object Dart_ListSetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListSetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListSetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListSetAsBytes');
  late final _Dart_ListSetAsBytes = _Dart_ListSetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the Object at some key of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  /// \param key An Object.
  ///
  /// \return The value in the map at the specified key, null if the map does not
  /// contain the key, or an error handle.
  Object Dart_MapGetAt(
    Object map,
    Object key,
  ) {
    return _Dart_MapGetAt(
      map,
      key,
    );
  }

  late final _Dart_MapGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapGetAt');
  late final _Dart_MapGetAt =
      _Dart_MapGetAtPtr.asFunction<Object Function(Object, Object)>();

  /// Returns whether the Map contains a given key.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return A handle on a boolean indicating whether map contains the key.
  /// Otherwise returns an error handle.
  Object Dart_MapContainsKey(
    Object map,
    Object key,
  ) {
    return _Dart_MapContainsKey(
      map,
      key,
    );
  }

  late final _Dart_MapContainsKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapContainsKey');
  late final _Dart_MapContainsKey =
      _Dart_MapContainsKeyPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the list of keys of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return The list of key Objects if no error occurs. Otherwise returns an
  /// error handle.
  Object Dart_MapKeys(
    Object map,
  ) {
    return _Dart_MapKeys(
      map,
    );
  }

  late final _Dart_MapKeysPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_MapKeys');
  late final _Dart_MapKeys =
      _Dart_MapKeysPtr.asFunction<Object Function(Object)>();

  /// Return type if this object is a TypedData object.
  ///
  /// \return kInvalid if the object is not a TypedData object or the appropriate
  /// Dart_TypedData_Type.
  int Dart_GetTypeOfTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfTypedData');
  late final _Dart_GetTypeOfTypedData =
      _Dart_GetTypeOfTypedDataPtr.asFunction<int Function(Object)>();

  /// Return type if this object is an external TypedData object.
  ///
  /// \return kInvalid if the object is not an external TypedData object or
  /// the appropriate Dart_TypedData_Type.
  int Dart_GetTypeOfExternalTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfExternalTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfExternalTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfExternalTypedData');
  late final _Dart_GetTypeOfExternalTypedData =
      _Dart_GetTypeOfExternalTypedDataPtr.asFunction<int Function(Object)>();

  /// Returns a TypedData object of the desired length and type.
  ///
  /// \param type The type of the TypedData object.
  /// \param length The length of the TypedData object (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewTypedData(
    int type,
    int length,
  ) {
    return _Dart_NewTypedData(
      type,
      length,
    );
  }

  late final _Dart_NewTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewTypedData');
  late final _Dart_NewTypedData =
      _Dart_NewTypedDataPtr.asFunction<Object Function(int, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedData(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _Dart_NewExternalTypedData(
      type,
      data,
      length,
    );
  }

  late final _Dart_NewExternalTypedDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_NewExternalTypedData');
  late final _Dart_NewExternalTypedData = _Dart_NewExternalTypedDataPtr
      .asFunction<Object Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedDataWithFinalizer(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalTypedDataWithFinalizer(
      type,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalTypedDataWithFinalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalTypedDataWithFinalizer');
  late final _Dart_NewExternalTypedDataWithFinalizer =
      _Dart_NewExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  Object Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
      type,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>, ffi.IntPtr,
                  ffi.Pointer<ffi.Void>, ffi.IntPtr, Dart_HandleFinalizer)>>(
      'Dart_NewUnmodifiableExternalTypedDataWithFinalizer');
  late final _Dart_NewUnmodifiableExternalTypedDataWithFinalizer =
      _Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Returns a ByteBuffer object for the typed data.
  ///
  /// \param typed_data The TypedData object.
  ///
  /// \return The ByteBuffer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewByteBuffer(
    Object typed_data,
  ) {
    return _Dart_NewByteBuffer(
      typed_data,
    );
  }

  late final _Dart_NewByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewByteBuffer');
  late final _Dart_NewByteBuffer =
      _Dart_NewByteBufferPtr.asFunction<Object Function(Object)>();

  /// Acquires access to the internal data address of a TypedData object.
  ///
  /// \param object The typed data object whose internal data address is to
  /// be accessed.
  /// \param type The type of the object is returned here.
  /// \param data The internal data address is returned here.
  /// \param len Size of the typed array is returned here.
  ///
  /// Notes:
  /// When the internal address of the object is acquired any calls to a
  /// Dart API function that could potentially allocate an object or run
  /// any Dart code will return an error.
  ///
  /// Any Dart API functions for accessing the data should not be called
  /// before the corresponding release. In particular, the object should
  /// not be acquired again before its release. This leads to undefined
  /// behavior.
  ///
  /// \return Success if the internal data address is acquired successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataAcquireData(
    Object object,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    ffi.Pointer<ffi.IntPtr> len,
  ) {
    return _Dart_TypedDataAcquireData(
      object,
      type,
      data,
      len,
    );
  }

  late final _Dart_TypedDataAcquireDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_TypedDataAcquireData');
  late final _Dart_TypedDataAcquireData =
      _Dart_TypedDataAcquireDataPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Releases access to the internal data address that was acquired earlier using
  /// Dart_TypedDataAcquireData.
  ///
  /// \param object The typed data object whose internal data address is to be
  /// released.
  ///
  /// \return Success if the internal data address is released successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataReleaseData(
    Object object,
  ) {
    return _Dart_TypedDataReleaseData(
      object,
    );
  }

  late final _Dart_TypedDataReleaseDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypedDataReleaseData');
  late final _Dart_TypedDataReleaseData =
      _Dart_TypedDataReleaseDataPtr.asFunction<Object Function(Object)>();

  /// Returns the TypedData object associated with the ByteBuffer object.
  ///
  /// \param byte_buffer The ByteBuffer object.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_GetDataFromByteBuffer(
    Object byte_buffer,
  ) {
    return _Dart_GetDataFromByteBuffer(
      byte_buffer,
    );
  }

  late final _Dart_GetDataFromByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_GetDataFromByteBuffer');
  late final _Dart_GetDataFromByteBuffer =
      _Dart_GetDataFromByteBufferPtr.asFunction<Object Function(Object)>();

  /// Invokes a constructor, creating a new object.
  ///
  /// This function allows hidden constructors (constructors with leading
  /// underscores) to be called.
  ///
  /// \param type Type of object to be constructed.
  /// \param constructor_name The name of the constructor to invoke.  Use
  /// Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// This name should not include the name of the class.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the constructor.
  ///
  /// \return If the constructor is called and completes successfully,
  /// then the new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_New(
    Object type,
    Object constructor_name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_New(
      type,
      constructor_name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_NewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_New');
  late final _Dart_New = _Dart_NewPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Allocate a new object without invoking a constructor.
  ///
  /// \param type The type of an object to be allocated.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_Allocate(
    Object type,
  ) {
    return _Dart_Allocate(
      type,
    );
  }

  late final _Dart_AllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_Allocate');
  late final _Dart_Allocate =
      _Dart_AllocatePtr.asFunction<Object Function(Object)>();

  /// Allocate a new object without invoking a constructor, and sets specified
  /// native fields.
  ///
  /// \param type The type of an object to be allocated.
  /// \param num_native_fields The number of native fields to set.
  /// \param native_fields An array containing the value of native fields.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_AllocateWithNativeFields(
    Object type,
    int num_native_fields,
    ffi.Pointer<ffi.IntPtr> native_fields,
  ) {
    return _Dart_AllocateWithNativeFields(
      type,
      num_native_fields,
      native_fields,
    );
  }

  late final _Dart_AllocateWithNativeFieldsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_AllocateWithNativeFields');
  late final _Dart_AllocateWithNativeFields = _Dart_AllocateWithNativeFieldsPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Invokes a method or function.
  ///
  /// The 'target' parameter may be an object, type, or library.  If
  /// 'target' is an object, then this function will invoke an instance
  /// method.  If 'target' is a type, then this function will invoke a
  /// static method.  If 'target' is a library, then this function will
  /// invoke a top-level function from that library.
  /// NOTE: This API call cannot be used to invoke methods of a type object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param target An object, type, or library.
  /// \param name The name of the function or method to invoke.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the function or method is called and completes
  /// successfully, then the return value is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_Invoke(
    Object target,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_Invoke(
      target,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_Invoke');
  late final _Dart_Invoke = _Dart_InvokePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Closure with the given arguments.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return If no error occurs during execution, then the result of
  /// invoking the closure is returned. If an error occurs during
  /// execution, then an error handle is returned.
  Object Dart_InvokeClosure(
    Object closure,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeClosure(
      closure,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeClosure');
  late final _Dart_InvokeClosure = _Dart_InvokeClosurePtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Generative Constructor on an object that was previously
  /// allocated using Dart_Allocate/Dart_AllocateWithNativeFields.
  ///
  /// The 'object' parameter must be an object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param object An object.
  /// \param name The name of the constructor to invoke.
  /// Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the constructor is called and completes
  /// successfully, then the object is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_InvokeConstructor(
    Object object,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeConstructor(
      object,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeConstructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeConstructor');
  late final _Dart_InvokeConstructor = _Dart_InvokeConstructorPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Gets the value of a field.
  ///
  /// The 'container' parameter may be an object, type, or library.  If
  /// 'container' is an object, then this function will access an
  /// instance field.  If 'container' is a type, then this function will
  /// access a static field.  If 'container' is a library, then this
  /// function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  ///
  /// \return If no error occurs, then the value of the field is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetField(
    Object container,
    Object name,
  ) {
    return _Dart_GetField(
      container,
      name,
    );
  }

  late final _Dart_GetFieldPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetField');
  late final _Dart_GetField =
      _Dart_GetFieldPtr.asFunction<Object Function(Object, Object)>();

  /// Sets the value of a field.
  ///
  /// The 'container' parameter may actually be an object, type, or
  /// library.  If 'container' is an object, then this function will
  /// access an instance field.  If 'container' is a type, then this
  /// function will access a static field.  If 'container' is a library,
  /// then this function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  /// \param value The new field value.
  ///
  /// \return A valid handle if no error occurs.
  Object Dart_SetField(
    Object container,
    Object name,
    Object value,
  ) {
    return _Dart_SetField(
      container,
      name,
      value,
    );
  }

  late final _Dart_SetFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.Handle)>>('Dart_SetField');
  late final _Dart_SetField =
      _Dart_SetFieldPtr.asFunction<Object Function(Object, Object, Object)>();

  /// Throws an exception.
  ///
  /// This function causes a Dart language exception to be thrown. This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If an error handle is passed into this function, the error is
  /// propagated immediately.  See Dart_PropagateError for a discussion
  /// of error propagation.
  ///
  /// If successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ThrowException(
    Object exception,
  ) {
    return _Dart_ThrowException(
      exception,
    );
  }

  late final _Dart_ThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ThrowException');
  late final _Dart_ThrowException =
      _Dart_ThrowExceptionPtr.asFunction<Object Function(Object)>();

  /// Rethrows an exception.
  ///
  /// Rethrows an exception, unwinding all dart frames on the stack. If
  /// successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ReThrowException(
    Object exception,
    Object stacktrace,
  ) {
    return _Dart_ReThrowException(
      exception,
      stacktrace,
    );
  }

  late final _Dart_ReThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_ReThrowException');
  late final _Dart_ReThrowException =
      _Dart_ReThrowExceptionPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the number of native instance fields in an object.
  Object Dart_GetNativeInstanceFieldCount(
    Object obj,
    ffi.Pointer<ffi.Int> count,
  ) {
    return _Dart_GetNativeInstanceFieldCount(
      obj,
      count,
    );
  }

  late final _Dart_GetNativeInstanceFieldCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Int>)>>('Dart_GetNativeInstanceFieldCount');
  late final _Dart_GetNativeInstanceFieldCount =
      _Dart_GetNativeInstanceFieldCountPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int>)>();

  /// Gets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_GetNativeInstanceField(
    Object obj,
    int index,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_GetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeInstanceField');
  late final _Dart_GetNativeInstanceField = _Dart_GetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Sets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetNativeInstanceField(
    Object obj,
    int index,
    int value,
  ) {
    return _Dart_SetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_SetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Int, ffi.IntPtr)>>('Dart_SetNativeInstanceField');
  late final _Dart_SetNativeInstanceField = _Dart_SetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, int)>();

  /// Extracts current isolate group data from the native arguments structure.
  ffi.Pointer<ffi.Void> Dart_GetNativeIsolateGroupData(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeIsolateGroupData(
      args,
    );
  }

  late final _Dart_GetNativeIsolateGroupDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              Dart_NativeArguments)>>('Dart_GetNativeIsolateGroupData');
  late final _Dart_GetNativeIsolateGroupData =
      _Dart_GetNativeIsolateGroupDataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(Dart_NativeArguments)>();

  /// Gets the native arguments based on the types passed in and populates
  /// the passed arguments buffer with appropriate native values.
  ///
  /// \param args the Native arguments block passed into the native call.
  /// \param num_arguments length of argument descriptor array and argument
  /// values array passed in.
  /// \param arg_descriptors an array that describes the arguments that
  /// need to be retrieved. For each argument to be retrieved the descriptor
  /// contains the argument number (0, 1 etc.) and the argument type
  /// described using Dart_NativeArgument_Type, e.g:
  /// DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates
  /// that the first argument is to be retrieved and it should be a boolean.
  /// \param arg_values array into which the native arguments need to be
  /// extracted into, the array is allocated by the caller (it could be
  /// stack allocated to avoid the malloc/free performance overhead).
  ///
  /// \return Success if all the arguments could be extracted correctly,
  /// returns an error handle if there were any errors while extracting the
  /// arguments (mismatched number of arguments, incorrect types, etc.).
  Object Dart_GetNativeArguments(
    Dart_NativeArguments args,
    int num_arguments,
    ffi.Pointer<Dart_NativeArgument_Descriptor> arg_descriptors,
    ffi.Pointer<Dart_NativeArgument_Value> arg_values,
  ) {
    return _Dart_GetNativeArguments(
      args,
      num_arguments,
      arg_descriptors,
      arg_values,
    );
  }

  late final _Dart_GetNativeArgumentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments,
                  ffi.Int,
                  ffi.Pointer<Dart_NativeArgument_Descriptor>,
                  ffi.Pointer<Dart_NativeArgument_Value>)>>(
      'Dart_GetNativeArguments');
  late final _Dart_GetNativeArguments = _Dart_GetNativeArgumentsPtr.asFunction<
      Object Function(
          Dart_NativeArguments,
          int,
          ffi.Pointer<Dart_NativeArgument_Descriptor>,
          ffi.Pointer<Dart_NativeArgument_Value>)>();

  /// Gets the native argument at some index.
  Object Dart_GetNativeArgument(
    Dart_NativeArguments args,
    int index,
  ) {
    return _Dart_GetNativeArgument(
      args,
      index,
    );
  }

  late final _Dart_GetNativeArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_NativeArguments, ffi.Int)>>('Dart_GetNativeArgument');
  late final _Dart_GetNativeArgument = _Dart_GetNativeArgumentPtr.asFunction<
      Object Function(Dart_NativeArguments, int)>();

  /// Gets the number of native arguments.
  int Dart_GetNativeArgumentCount(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeArgumentCount(
      args,
    );
  }

  late final _Dart_GetNativeArgumentCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Dart_NativeArguments)>>(
          'Dart_GetNativeArgumentCount');
  late final _Dart_GetNativeArgumentCount = _Dart_GetNativeArgumentCountPtr
      .asFunction<int Function(Dart_NativeArguments)>();

  /// Gets all the native fields of the native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param num_fields size of the intptr_t array 'field_values' passed in.
  /// \param field_values intptr_t array in which native field values are returned.
  /// \return Success if the native fields where copied in successfully. Otherwise
  /// returns an error handle. On success the native field values are copied
  /// into the 'field_values' array, if the argument at 'arg_index' is a
  /// null object then 0 is copied as the native field values into the
  /// 'field_values' array.
  Object Dart_GetNativeFieldsOfArgument(
    Dart_NativeArguments args,
    int arg_index,
    int num_fields,
    ffi.Pointer<ffi.IntPtr> field_values,
  ) {
    return _Dart_GetNativeFieldsOfArgument(
      args,
      arg_index,
      num_fields,
      field_values,
    );
  }

  late final _Dart_GetNativeFieldsOfArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeFieldsOfArgument');
  late final _Dart_GetNativeFieldsOfArgument =
      _Dart_GetNativeFieldsOfArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the native field of the receiver.
  Object Dart_GetNativeReceiver(
    Dart_NativeArguments args,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeReceiver(
      args,
      value,
    );
  }

  late final _Dart_GetNativeReceiverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeReceiver');
  late final _Dart_GetNativeReceiver = _Dart_GetNativeReceiverPtr.asFunction<
      Object Function(Dart_NativeArguments, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets a string native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param peer Returns the peer pointer if the string argument has one.
  /// \return Success if the string argument has a peer, if it does not
  /// have a peer then the String object is returned. Otherwise returns
  /// an error handle (argument is not a String object).
  Object Dart_GetNativeStringArgument(
    Dart_NativeArguments args,
    int arg_index,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetNativeStringArgument(
      args,
      arg_index,
      peer,
    );
  }

  late final _Dart_GetNativeStringArgumentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'Dart_GetNativeStringArgument');
  late final _Dart_GetNativeStringArgument =
      _Dart_GetNativeStringArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Gets an integer native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the integer value if the argument is an Integer.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeIntegerArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_GetNativeIntegerArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeIntegerArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('Dart_GetNativeIntegerArgument');
  late final _Dart_GetNativeIntegerArgument =
      _Dart_GetNativeIntegerArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Int64>)>();

  /// Gets a boolean native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the boolean value if the argument is a Boolean.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeBooleanArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_GetNativeBooleanArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeBooleanArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Bool>)>>('Dart_GetNativeBooleanArgument');
  late final _Dart_GetNativeBooleanArgument =
      _Dart_GetNativeBooleanArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Bool>)>();

  /// Gets a double native argument at some index.
  /// \param args Native arguments structure.
  /// \param index Index of the desired argument in the structure above.
  /// \param value Returns the double value if the argument is a double.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeDoubleArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_GetNativeDoubleArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeDoubleArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Double>)>>('Dart_GetNativeDoubleArgument');
  late final _Dart_GetNativeDoubleArgument =
      _Dart_GetNativeDoubleArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Double>)>();

  /// Sets the return value for a native function.
  ///
  /// If retval is an Error handle, then error will be propagated once
  /// the native functions exits. See Dart_PropagateError for a
  /// discussion of how different types of errors are propagated.
  void Dart_SetReturnValue(
    Dart_NativeArguments args,
    Object retval,
  ) {
    return _Dart_SetReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Handle)>>('Dart_SetReturnValue');
  late final _Dart_SetReturnValue = _Dart_SetReturnValuePtr.asFunction<
      void Function(Dart_NativeArguments, Object)>();

  void Dart_SetWeakHandleReturnValue(
    Dart_NativeArguments args,
    Dart_WeakPersistentHandle rval,
  ) {
    return _Dart_SetWeakHandleReturnValue(
      args,
      rval,
    );
  }

  late final _Dart_SetWeakHandleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_NativeArguments,
              Dart_WeakPersistentHandle)>>('Dart_SetWeakHandleReturnValue');
  late final _Dart_SetWeakHandleReturnValue =
      _Dart_SetWeakHandleReturnValuePtr.asFunction<
          void Function(Dart_NativeArguments, Dart_WeakPersistentHandle)>();

  void Dart_SetBooleanReturnValue(
    Dart_NativeArguments args,
    bool retval,
  ) {
    return _Dart_SetBooleanReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetBooleanReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Bool)>>('Dart_SetBooleanReturnValue');
  late final _Dart_SetBooleanReturnValue = _Dart_SetBooleanReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, bool)>();

  void Dart_SetIntegerReturnValue(
    Dart_NativeArguments args,
    int retval,
  ) {
    return _Dart_SetIntegerReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetIntegerReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Int64)>>('Dart_SetIntegerReturnValue');
  late final _Dart_SetIntegerReturnValue = _Dart_SetIntegerReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, int)>();

  void Dart_SetDoubleReturnValue(
    Dart_NativeArguments args,
    double retval,
  ) {
    return _Dart_SetDoubleReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetDoubleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Double)>>('Dart_SetDoubleReturnValue');
  late final _Dart_SetDoubleReturnValue = _Dart_SetDoubleReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, double)>();

  /// Sets the environment callback for the current isolate. This
  /// callback is used to lookup environment values by name in the
  /// current environment. This enables the embedder to supply values for
  /// the const constructors bool.fromEnvironment, int.fromEnvironment
  /// and String.fromEnvironment.
  Object Dart_SetEnvironmentCallback(
    Dart_EnvironmentCallback callback,
  ) {
    return _Dart_SetEnvironmentCallback(
      callback,
    );
  }

  late final _Dart_SetEnvironmentCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_EnvironmentCallback)>>(
      'Dart_SetEnvironmentCallback');
  late final _Dart_SetEnvironmentCallback = _Dart_SetEnvironmentCallbackPtr
      .asFunction<Object Function(Dart_EnvironmentCallback)>();

  /// Sets the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver A native entry resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetNativeResolver(
    Object library1,
    Dart_NativeEntryResolver resolver,
    Dart_NativeEntrySymbol symbol,
  ) {
    return _Dart_SetNativeResolver(
      library1,
      resolver,
      symbol,
    );
  }

  late final _Dart_SetNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, Dart_NativeEntryResolver,
              Dart_NativeEntrySymbol)>>('Dart_SetNativeResolver');
  late final _Dart_SetNativeResolver = _Dart_SetNativeResolverPtr.asFunction<
      Object Function(
          Object, Dart_NativeEntryResolver, Dart_NativeEntrySymbol)>();

  /// Returns the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntryResolver
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeResolver(
    Object library1,
    ffi.Pointer<Dart_NativeEntryResolver> resolver,
  ) {
    return _Dart_GetNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeResolverPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntryResolver>)>>(
      'Dart_GetNativeResolver');
  late final _Dart_GetNativeResolver = _Dart_GetNativeResolverPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntryResolver>)>();

  /// Returns the callback used to resolve native function symbols for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntrySymbol.
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeSymbol(
    Object library1,
    ffi.Pointer<Dart_NativeEntrySymbol> resolver,
  ) {
    return _Dart_GetNativeSymbol(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeSymbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<Dart_NativeEntrySymbol>)>>('Dart_GetNativeSymbol');
  late final _Dart_GetNativeSymbol = _Dart_GetNativeSymbolPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntrySymbol>)>();

  /// Sets the callback used to resolve FFI native functions for a library.
  /// The resolved functions are expected to be a C function pointer of the
  /// correct signature (as specified in the `@FfiNative<NFT>()` function
  /// annotation in Dart code).
  ///
  /// NOTE: This is an experimental feature and might change in the future.
  ///
  /// \param library A library.
  /// \param resolver A native function resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetFfiNativeResolver(
    Object library1,
    Dart_FfiNativeResolver resolver,
  ) {
    return _Dart_SetFfiNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_SetFfiNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              Dart_FfiNativeResolver)>>('Dart_SetFfiNativeResolver');
  late final _Dart_SetFfiNativeResolver = _Dart_SetFfiNativeResolverPtr
      .asFunction<Object Function(Object, Dart_FfiNativeResolver)>();

  /// Sets library tag handler for the current isolate. This handler is
  /// used to handle the various tags encountered while loading libraries
  /// or scripts in the isolate.
  ///
  /// \param handler Handler code to be used for handling the various tags
  /// encountered while loading libraries or scripts in the isolate.
  ///
  /// \return If no error occurs, the handler is set for the isolate.
  /// Otherwise an error handle is returned.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetLibraryTagHandler(
    Dart_LibraryTagHandler handler,
  ) {
    return _Dart_SetLibraryTagHandler(
      handler,
    );
  }

  late final _Dart_SetLibraryTagHandlerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_LibraryTagHandler)>>(
          'Dart_SetLibraryTagHandler');
  late final _Dart_SetLibraryTagHandler = _Dart_SetLibraryTagHandlerPtr
      .asFunction<Object Function(Dart_LibraryTagHandler)>();

  /// Sets the deferred load handler for the current isolate. This handler is
  /// used to handle loading deferred imports in an AppJIT or AppAOT program.
  Object Dart_SetDeferredLoadHandler(
    Dart_DeferredLoadHandler handler,
  ) {
    return _Dart_SetDeferredLoadHandler(
      handler,
    );
  }

  late final _Dart_SetDeferredLoadHandlerPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_DeferredLoadHandler)>>(
      'Dart_SetDeferredLoadHandler');
  late final _Dart_SetDeferredLoadHandler = _Dart_SetDeferredLoadHandlerPtr
      .asFunction<Object Function(Dart_DeferredLoadHandler)>();

  /// Notifies the VM that a deferred load completed successfully. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadComplete(
    int loading_unit_id,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
  ) {
    return _Dart_DeferredLoadComplete(
      loading_unit_id,
      snapshot_data,
      snapshot_instructions,
    );
  }

  late final _Dart_DeferredLoadCompletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>)>>('Dart_DeferredLoadComplete');
  late final _Dart_DeferredLoadComplete =
      _Dart_DeferredLoadCompletePtr.asFunction<
          Object Function(
              int, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>();

  /// Notifies the VM that a deferred load failed. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete with an error.
  ///
  /// If `transient` is true, future invocations of `prefix.loadLibrary()` will
  /// trigger new load requests. If false, futures invocation will complete with
  /// the same error.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadCompleteError(
    int loading_unit_id,
    ffi.Pointer<ffi.Char> error_message,
    bool transient,
  ) {
    return _Dart_DeferredLoadCompleteError(
      loading_unit_id,
      error_message,
      transient,
    );
  }

  late final _Dart_DeferredLoadCompleteErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('Dart_DeferredLoadCompleteError');
  late final _Dart_DeferredLoadCompleteError =
      _Dart_DeferredLoadCompleteErrorPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Canonicalizes a url with respect to some library.
  ///
  /// The url is resolved with respect to the library's url and some url
  /// normalizations are performed.
  ///
  /// This canonicalization function should be sufficient for most
  /// embedders to implement the Dart_kCanonicalizeUrl tag.
  ///
  /// \param base_url The base url relative to which the url is
  /// being resolved.
  /// \param url The url being resolved and canonicalized.  This
  /// parameter is a string handle.
  ///
  /// \return If no error occurs, a String object is returned.  Otherwise
  /// an error handle is returned.
  Object Dart_DefaultCanonicalizeUrl(
    Object base_url,
    Object url,
  ) {
    return _Dart_DefaultCanonicalizeUrl(
      base_url,
      url,
    );
  }

  late final _Dart_DefaultCanonicalizeUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_DefaultCanonicalizeUrl');
  late final _Dart_DefaultCanonicalizeUrl = _Dart_DefaultCanonicalizeUrlPtr
      .asFunction<Object Function(Object, Object)>();

  /// Loads the root library for the current isolate.
  ///
  /// Requires there to be no current root library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate group shutdown.
  /// \param kernel_size Length of the passed in buffer.
  ///
  /// \return A handle to the root library, or an error.
  Object Dart_LoadScriptFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_size,
  ) {
    return _Dart_LoadScriptFromKernel(
      kernel_buffer,
      kernel_size,
    );
  }

  late final _Dart_LoadScriptFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadScriptFromKernel');
  late final _Dart_LoadScriptFromKernel = _Dart_LoadScriptFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the library for the root script for the current isolate.
  ///
  /// If the root script has not yet been set for the current isolate,
  /// this function returns Dart_Null().  This function never returns an
  /// error handle.
  ///
  /// \return Returns the root Library for the current isolate or Dart_Null().
  Object Dart_RootLibrary() {
    return _Dart_RootLibrary();
  }

  late final _Dart_RootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RootLibrary');
  late final _Dart_RootLibrary =
      _Dart_RootLibraryPtr.asFunction<Object Function()>();

  /// Sets the root library for the current isolate.
  ///
  /// \return Returns an error handle if `library` is not a library handle.
  Object Dart_SetRootLibrary(
    Object library1,
  ) {
    return _Dart_SetRootLibrary(
      library1,
    );
  }

  late final _Dart_SetRootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_SetRootLibrary');
  late final _Dart_SetRootLibrary =
      _Dart_SetRootLibraryPtr.asFunction<Object Function(Object)>();

  /// Lookup or instantiate a legacy type by name and type arguments from a
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetType');
  late final _Dart_GetType = _Dart_GetTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNullableType');
  late final _Dart_GetNullableType = _Dart_GetNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a non-nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNonNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNonNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNonNullableType');
  late final _Dart_GetNonNullableType = _Dart_GetNonNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Creates a nullable version of the provided type.
  ///
  /// \param type The type to be converted to a nullable type.
  ///
  /// \return If no error occurs, a nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNullableType(
    Object type,
  ) {
    return _Dart_TypeToNullableType(
      type,
    );
  }

  late final _Dart_TypeToNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNullableType');
  late final _Dart_TypeToNullableType =
      _Dart_TypeToNullableTypePtr.asFunction<Object Function(Object)>();

  /// Creates a non-nullable version of the provided type.
  ///
  /// \param type The type to be converted to a non-nullable type.
  ///
  /// \return If no error occurs, a non-nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNonNullableType(
    Object type,
  ) {
    return _Dart_TypeToNonNullableType(
      type,
    );
  }

  late final _Dart_TypeToNonNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNonNullableType');
  late final _Dart_TypeToNonNullableType =
      _Dart_TypeToNonNullableTypePtr.asFunction<Object Function(Object)>();

  /// A type's nullability.
  ///
  /// \param type A Dart type.
  /// \param result An out parameter containing the result of the check. True if
  /// the type is of the specified nullability, false otherwise.
  ///
  /// \return Returns an error handle if type is not of type Type.
  Object Dart_IsNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNullableType');
  late final _Dart_IsNullableType = _Dart_IsNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsNonNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNonNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNonNullableType');
  late final _Dart_IsNonNullableType = _Dart_IsNonNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsLegacyType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsLegacyType(
      type,
      result,
    );
  }

  late final _Dart_IsLegacyTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsLegacyType');
  late final _Dart_IsLegacyType = _Dart_IsLegacyTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Lookup a class or interface by name from a Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The name of the class or interface.
  ///
  /// \return If no error occurs, the class or interface is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetClass(
    Object library1,
    Object class_name,
  ) {
    return _Dart_GetClass(
      library1,
      class_name,
    );
  }

  late final _Dart_GetClassPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetClass');
  late final _Dart_GetClass =
      _Dart_GetClassPtr.asFunction<Object Function(Object, Object)>();

  /// Returns an import path to a Library, such as "file:///test.dart" or
  /// "dart:core".
  Object Dart_LibraryUrl(
    Object library1,
  ) {
    return _Dart_LibraryUrl(
      library1,
    );
  }

  late final _Dart_LibraryUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryUrl');
  late final _Dart_LibraryUrl =
      _Dart_LibraryUrlPtr.asFunction<Object Function(Object)>();

  /// Returns a URL from which a Library was loaded.
  Object Dart_LibraryResolvedUrl(
    Object library1,
  ) {
    return _Dart_LibraryResolvedUrl(
      library1,
    );
  }

  late final _Dart_LibraryResolvedUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryResolvedUrl');
  late final _Dart_LibraryResolvedUrl =
      _Dart_LibraryResolvedUrlPtr.asFunction<Object Function(Object)>();

  /// \return An array of libraries.
  Object Dart_GetLoadedLibraries() {
    return _Dart_GetLoadedLibraries();
  }

  late final _Dart_GetLoadedLibrariesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_GetLoadedLibraries');
  late final _Dart_GetLoadedLibraries =
      _Dart_GetLoadedLibrariesPtr.asFunction<Object Function()>();

  Object Dart_LookupLibrary(
    Object url,
  ) {
    return _Dart_LookupLibrary(
      url,
    );
  }

  late final _Dart_LookupLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LookupLibrary');
  late final _Dart_LookupLibrary =
      _Dart_LookupLibraryPtr.asFunction<Object Function(Object)>();

  /// Report an loading error for the library.
  ///
  /// \param library The library that failed to load.
  /// \param error The Dart error instance containing the load error.
  ///
  /// \return If the VM handles the error, the return value is
  /// a null handle. If it doesn't handle the error, the error
  /// object is returned.
  Object Dart_LibraryHandleError(
    Object library1,
    Object error,
  ) {
    return _Dart_LibraryHandleError(
      library1,
      error,
    );
  }

  late final _Dart_LibraryHandleErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_LibraryHandleError');
  late final _Dart_LibraryHandleError =
      _Dart_LibraryHandleErrorPtr.asFunction<Object Function(Object, Object)>();

  /// Called by the embedder to load a partial program. Does not set the root
  /// library.
  ///
  /// \param kernel_buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate shutdown.
  /// \param kernel_buffer_size Length of the passed in buffer.
  ///
  /// \return A handle to the main library of the compilation unit, or an error.
  Object Dart_LoadLibraryFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_LoadLibraryFromKernel(
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_LoadLibraryFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadLibraryFromKernel');
  late final _Dart_LoadLibraryFromKernel = _Dart_LoadLibraryFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Indicates that all outstanding load requests have been satisfied.
  /// This finalizes all the new classes loaded and optionally completes
  /// deferred library futures.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param complete_futures Specify true if all deferred library
  /// futures should be completed, false otherwise.
  ///
  /// \return Success if all classes have been finalized and deferred library
  /// futures are completed. Otherwise, returns an error.
  Object Dart_FinalizeLoading(
    bool complete_futures,
  ) {
    return _Dart_FinalizeLoading(
      complete_futures,
    );
  }

  late final _Dart_FinalizeLoadingPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_FinalizeLoading');
  late final _Dart_FinalizeLoading =
      _Dart_FinalizeLoadingPtr.asFunction<Object Function(bool)>();

  /// Returns the value of peer field of 'object' in 'peer'.
  ///
  /// \param object An object.
  /// \param peer An out parameter that returns the value of the peer
  /// field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_GetPeer(
    Object object,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetPeer(
      object,
      peer,
    );
  }

  late final _Dart_GetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_GetPeer');
  late final _Dart_GetPeer = _Dart_GetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Sets the value of the peer field of 'object' to the value of
  /// 'peer'.
  ///
  /// \param object An object.
  /// \param peer A value to store in the peer field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_SetPeer(
    Object object,
    ffi.Pointer<ffi.Void> peer,
  ) {
    return _Dart_SetPeer(
      object,
      peer,
    );
  }

  late final _Dart_SetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Void>)>>('Dart_SetPeer');
  late final _Dart_SetPeer = _Dart_SetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Void>)>();

  bool Dart_IsKernelIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsKernelIsolate(
      isolate,
    );
  }

  late final _Dart_IsKernelIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsKernelIsolate');
  late final _Dart_IsKernelIsolate =
      _Dart_IsKernelIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  bool Dart_KernelIsolateIsRunning() {
    return _Dart_KernelIsolateIsRunning();
  }

  late final _Dart_KernelIsolateIsRunningPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_KernelIsolateIsRunning');
  late final _Dart_KernelIsolateIsRunning =
      _Dart_KernelIsolateIsRunningPtr.asFunction<bool Function()>();

  int Dart_KernelPort() {
    return _Dart_KernelPort();
  }

  late final _Dart_KernelPortPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_KernelPort');
  late final _Dart_KernelPort =
      _Dart_KernelPortPtr.asFunction<int Function()>();

  /// Compiles the given `script_uri` to a kernel file.
  ///
  /// \param platform_kernel A buffer containing the kernel of the platform (e.g.
  /// `vm_platform_strong.dill`). The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  ///
  /// \param snapshot_compile Set to `true` when the compilation is for a snapshot.
  /// This is used by the frontend to determine if compilation related information
  /// should be printed to console (e.g., null safety mode).
  ///
  /// \param verbosity Specifies the logging behavior of the kernel compilation
  /// service.
  ///
  /// \return Returns the result of the compilation.
  ///
  /// On a successful compilation the returned [Dart_KernelCompilationResult] has
  /// a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`
  /// fields are set. The caller takes ownership of the malloc()ed buffer.
  ///
  /// On a failed compilation the `error` might be set describing the reason for
  /// the failed compilation. The caller takes ownership of the malloc()ed
  /// error.
  ///
  /// Requires there to be a current isolate.
  Dart_KernelCompilationResult Dart_CompileToKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
    bool incremental_compile,
    bool snapshot_compile,
    ffi.Pointer<ffi.Char> package_config,
    int verbosity,
  ) {
    return _Dart_CompileToKernel(
      script_uri,
      platform_kernel,
      platform_kernel_size,
      incremental_compile,
      snapshot_compile,
      package_config,
      verbosity,
    );
  }

  late final _Dart_CompileToKernelPtr = _lookup<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('Dart_CompileToKernel');
  late final _Dart_CompileToKernel = _Dart_CompileToKernelPtr.asFunction<
      Dart_KernelCompilationResult Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          int,
          bool,
          bool,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Compiles the given `script_uri` to a kernel file.
  ///
  /// \param platform_kernel A buffer containing the kernel of the platform (e.g.
  /// `vm_platform_strong.dill`). The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  ///
  /// \param snapshot_compile Set to `true` when the compilation is for a snapshot.
  /// This is used by the frontend to determine if compilation related information
  /// should be printed to console (e.g., null safety mode).
  ///
  /// \param null_safety Provides null-safety mode setting for the compiler.
  ///
  /// \param verbosity Specifies the logging behavior of the kernel compilation
  /// service.
  ///
  /// \return Returns the result of the compilation.
  ///
  /// On a successful compilation the returned [Dart_KernelCompilationResult] has
  /// a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`
  /// fields are set. The caller takes ownership of the malloc()ed buffer.
  ///
  /// On a failed compilation the `error` might be set describing the reason for
  /// the failed compilation. The caller takes ownership of the malloc()ed
  /// error.
  Dart_KernelCompilationResult Dart_CompileToKernelWithGivenNullsafety(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
    bool snapshot_compile,
    ffi.Pointer<ffi.Char> package_config,
    bool null_safety,
    int verbosity,
  ) {
    return _Dart_CompileToKernelWithGivenNullsafety(
      script_uri,
      platform_kernel,
      platform_kernel_size,
      snapshot_compile,
      package_config,
      null_safety,
      verbosity,
    );
  }

  late final _Dart_CompileToKernelWithGivenNullsafetyPtr = _lookup<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Int32)>>('Dart_CompileToKernelWithGivenNullsafety');
  late final _Dart_CompileToKernelWithGivenNullsafety =
      _Dart_CompileToKernelWithGivenNullsafetyPtr.asFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              int,
              bool,
              ffi.Pointer<ffi.Char>,
              bool,
              int)>();

  Dart_KernelCompilationResult Dart_KernelListDependencies() {
    return _Dart_KernelListDependencies();
  }

  late final _Dart_KernelListDependenciesPtr =
      _lookup<ffi.NativeFunction<Dart_KernelCompilationResult Function()>>(
          'Dart_KernelListDependencies');
  late final _Dart_KernelListDependencies = _Dart_KernelListDependenciesPtr
      .asFunction<Dart_KernelCompilationResult Function()>();

  /// Sets the kernel buffer which will be used to load Dart SDK sources
  /// dynamically at runtime.
  ///
  /// \param platform_kernel A buffer containing kernel which has sources for the
  /// Dart SDK populated. Note: The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  void Dart_SetDartLibrarySourcesKernel(
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
  ) {
    return _Dart_SetDartLibrarySourcesKernel(
      platform_kernel,
      platform_kernel_size,
    );
  }

  late final _Dart_SetDartLibrarySourcesKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_SetDartLibrarySourcesKernel');
  late final _Dart_SetDartLibrarySourcesKernel =
      _Dart_SetDartLibrarySourcesKernelPtr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Detect the null safety opt-in status.
  ///
  /// When running from source, it is based on the opt-in status of `script_uri`.
  /// When running from a kernel buffer, it is based on the mode used when
  /// generating `kernel_buffer`.
  /// When running from an appJIT or AOT snapshot, it is based on the mode used
  /// when generating `snapshot_data`.
  ///
  /// \param script_uri Uri of the script that contains the source code
  ///
  /// \param package_config Uri of the package configuration file (either in format
  /// of .packages or .dart_tool/package_config.json) for the null safety
  /// detection to resolve package imports against. If this parameter is not
  /// passed the package resolution of the parent isolate should be used.
  ///
  /// \param original_working_directory current working directory when the VM
  /// process was launched, this is used to correctly resolve the path specified
  /// for package_config.
  ///
  /// \param snapshot_data Buffer containing the snapshot data of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffers must
  /// remain valid until the isolate shuts down.
  ///
  /// \param snapshot_instructions Buffer containing the snapshot instructions of
  /// the isolate or NULL if no snapshot is provided. If provided, the buffers
  /// must remain valid until the isolate shuts down.
  ///
  /// \param kernel_buffer A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  ///
  /// \param kernel_buffer_size The size of `kernel_buffer`.
  ///
  /// \return Returns true if the null safety is opted in by the input being
  /// run `script_uri`, `snapshot_data` or `kernel_buffer`.
  bool Dart_DetectNullSafety(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> package_config,
    ffi.Pointer<ffi.Char> original_working_directory,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_DetectNullSafety(
      script_uri,
      package_config,
      original_working_directory,
      snapshot_data,
      snapshot_instructions,
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_DetectNullSafetyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_DetectNullSafety');
  late final _Dart_DetectNullSafety = _Dart_DetectNullSafetyPtr.asFunction<
      bool Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// Returns true if isolate is the service isolate.
  ///
  /// \param isolate An isolate
  ///
  /// \return Returns true if 'isolate' is the service isolate.
  bool Dart_IsServiceIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsServiceIsolate(
      isolate,
    );
  }

  late final _Dart_IsServiceIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsServiceIsolate');
  late final _Dart_IsServiceIsolate =
      _Dart_IsServiceIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  /// Writes the CPU profile to the timeline as a series of 'instant' events.
  ///
  /// Note that this is an expensive operation.
  ///
  /// \param main_port The main port of the Isolate whose profile samples to write.
  /// \param error An optional error, must be free()ed by caller.
  ///
  /// \return Returns true if the profile is successfully written and false
  /// otherwise.
  bool Dart_WriteProfileToTimeline(
    int main_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_WriteProfileToTimeline(
      main_port,
      error,
    );
  }

  late final _Dart_WriteProfileToTimelinePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  Dart_Port, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_WriteProfileToTimeline');
  late final _Dart_WriteProfileToTimeline = _Dart_WriteProfileToTimelinePtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Compiles all functions reachable from entry points and marks
  /// the isolate to disallow future compilation.
  ///
  /// Entry points should be specified using `@pragma("vm:entry-point")`
  /// annotation.
  ///
  /// \return An error handle if a compilation error or runtime error running const
  /// constructors was encountered.
  Object Dart_Precompile() {
    return _Dart_Precompile();
  }

  late final _Dart_PrecompilePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Precompile');
  late final _Dart_Precompile =
      _Dart_PrecompilePtr.asFunction<Object Function()>();

  Object Dart_LoadingUnitLibraryUris(
    int loading_unit_id,
  ) {
    return _Dart_LoadingUnitLibraryUris(
      loading_unit_id,
    );
  }

  late final _Dart_LoadingUnitLibraryUrisPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_LoadingUnitLibraryUris');
  late final _Dart_LoadingUnitLibraryUris =
      _Dart_LoadingUnitLibraryUrisPtr.asFunction<Object Function(int)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an assembly file defining the symbols listed in the definitions
  /// above.
  ///
  /// The assembly should be compiled as a static or shared library and linked or
  /// loaded by the embedder. Running this snapshot requires a VM compiled with
  /// DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and
  /// kDartVmSnapshotInstructions should be passed to Dart_Initialize. The
  /// kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be
  /// passed to Dart_CreateIsolateGroup.
  ///
  /// The callback will be invoked one or more times to provide the assembly code.
  ///
  /// If stripped is true, then the assembly code will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssembly(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsAssembly');
  late final _Dart_CreateAppAOTSnapshotAsAssembly =
      _Dart_CreateAppAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsAssemblies(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssemblies(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssembliesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>(
      'Dart_CreateAppAOTSnapshotAsAssemblies');
  late final _Dart_CreateAppAOTSnapshotAsAssemblies =
      _Dart_CreateAppAOTSnapshotAsAssembliesPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an ELF shared library defining the symbols
  /// - _kDartVmSnapshotData
  /// - _kDartVmSnapshotInstructions
  /// - _kDartIsolateSnapshotData
  /// - _kDartIsolateSnapshotInstructions
  ///
  /// The shared library should be dynamically loaded by the embedder.
  /// Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.
  /// The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to
  /// Dart_Initialize. The kDartIsolateSnapshotData and
  /// kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.
  ///
  /// The callback will be invoked one or more times to provide the binary output.
  ///
  /// If stripped is true, then the binary output will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsElf(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElf(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsElf');
  late final _Dart_CreateAppAOTSnapshotAsElf =
      _Dart_CreateAppAOTSnapshotAsElfPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsElfs(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElfs(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>>('Dart_CreateAppAOTSnapshotAsElfs');
  late final _Dart_CreateAppAOTSnapshotAsElfs =
      _Dart_CreateAppAOTSnapshotAsElfsPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes
  /// kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does
  /// not strip DWARF information from the generated assembly or allow for
  /// separate debug information.
  Object Dart_CreateVMAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _Dart_CreateVMAOTSnapshotAsAssembly(
      callback,
      callback_data,
    );
  }

  late final _Dart_CreateVMAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateVMAOTSnapshotAsAssembly');
  late final _Dart_CreateVMAOTSnapshotAsAssembly =
      _Dart_CreateVMAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(
              Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>)>();

  /// Sorts the class-ids in depth first traversal order of the inheritance
  /// tree. This is a costly operation, but it can make method dispatch
  /// more efficient and is done before writing snapshots.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_SortClasses() {
    return _Dart_SortClasses();
  }

  late final _Dart_SortClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_SortClasses');
  late final _Dart_SortClasses =
      _Dart_SortClassesPtr.asFunction<Object Function()>();

  /// Creates a snapshot that caches compiled code and type feedback for faster
  /// startup and quicker warmup in a subsequent process.
  ///
  /// Outputs a snapshot in two pieces. The pieces should be passed to
  /// Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the
  /// current VM. The instructions piece must be loaded with read and execute
  /// permissions; the data piece may be loaded as read-only.
  ///
  /// - Requires the VM to have not been started with --precompilation.
  /// - Not supported when targeting IA32.
  /// - The VM writing the snapshot and the VM reading the snapshot must be the
  /// same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must
  /// be targeting the same architecture, and must both be in checked mode or
  /// both in unchecked mode.
  ///
  /// The buffers are scope allocated and are only valid until the next call to
  /// Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateAppJITSnapshotAsBlobs(
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateAppJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateAppJITSnapshotAsBlobs');
  late final _Dart_CreateAppJITSnapshotAsBlobs =
      _Dart_CreateAppJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Like Dart_CreateAppJITSnapshotAsBlobs, but also creates a new VM snapshot.
  Object Dart_CreateCoreJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_instructions_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateCoreJITSnapshotAsBlobs(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      vm_snapshot_instructions_buffer,
      vm_snapshot_instructions_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateCoreJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateCoreJITSnapshotAsBlobs');
  late final _Dart_CreateCoreJITSnapshotAsBlobs =
      _Dart_CreateCoreJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Get obfuscation map for precompiled code.
  ///
  /// Obfuscation map is encoded as a JSON array of pairs (original name,
  /// obfuscated name).
  ///
  /// \return Returns an error handler if the VM was built in a mode that does not
  /// support obfuscation.
  Object Dart_GetObfuscationMap(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.IntPtr> buffer_length,
  ) {
    return _Dart_GetObfuscationMap(
      buffer,
      buffer_length,
    );
  }

  late final _Dart_GetObfuscationMapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetObfuscationMap');
  late final _Dart_GetObfuscationMap = _Dart_GetObfuscationMapPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns whether the VM only supports running from precompiled snapshots and
  /// not from any other kind of snapshot or from source (that is, the VM was
  /// compiled with DART_PRECOMPILED_RUNTIME).
  bool Dart_IsPrecompiledRuntime() {
    return _Dart_IsPrecompiledRuntime();
  }

  late final _Dart_IsPrecompiledRuntimePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_IsPrecompiledRuntime');
  late final _Dart_IsPrecompiledRuntime =
      _Dart_IsPrecompiledRuntimePtr.asFunction<bool Function()>();

  /// Print a native stack trace. Used for crash handling.
  ///
  /// If context is NULL, prints the current stack trace. Otherwise, context
  /// should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler
  /// running on the current thread.
  void Dart_DumpNativeStackTrace(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _Dart_DumpNativeStackTrace(
      context,
    );
  }

  late final _Dart_DumpNativeStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_DumpNativeStackTrace');
  late final _Dart_DumpNativeStackTrace = _Dart_DumpNativeStackTracePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Indicate that the process is about to abort, and the Dart VM should not
  /// attempt to cleanup resources.
  void Dart_PrepareToAbort() {
    return _Dart_PrepareToAbort();
  }

  late final _Dart_PrepareToAbortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_PrepareToAbort');
  late final _Dart_PrepareToAbort =
      _Dart_PrepareToAbortPtr.asFunction<void Function()>();

  int tarantool_generate_owner_id() {
    return _tarantool_generate_owner_id();
  }

  late final _tarantool_generate_owner_idPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'tarantool_generate_owner_id');
  late final _tarantool_generate_owner_id =
      _tarantool_generate_owner_idPtr.asFunction<int Function()>();

  void tarantool_initialize(
    ffi.Pointer<ffi.Char> binary_path,
    ffi.Pointer<ffi.Char> script,
    ffi.Pointer<tarantool_configuration_t> configuration,
  ) {
    return _tarantool_initialize(
      binary_path,
      script,
      configuration,
    );
  }

  late final _tarantool_initializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<tarantool_configuration_t>)>>('tarantool_initialize');
  late final _tarantool_initialize = _tarantool_initializePtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tarantool_configuration_t>)>();

  bool tarantool_initialized() {
    return _tarantool_initialized();
  }

  late final _tarantool_initializedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('tarantool_initialized');
  late final _tarantool_initialized =
      _tarantool_initializedPtr.asFunction<bool Function()>();

  void tarantool_shutdown(
    int code,
  ) {
    return _tarantool_shutdown(
      code,
    );
  }

  late final _tarantool_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'tarantool_shutdown');
  late final _tarantool_shutdown =
      _tarantool_shutdownPtr.asFunction<void Function(int)>();

  void tarantool_message_loop_initialize(
    ffi.Pointer<tarantool_message_loop_configuration_t> configuration,
  ) {
    return _tarantool_message_loop_initialize(
      configuration,
    );
  }

  late final _tarantool_message_loop_initializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<tarantool_message_loop_configuration_t>)>>(
      'tarantool_message_loop_initialize');
  late final _tarantool_message_loop_initialize =
      _tarantool_message_loop_initializePtr.asFunction<
          void Function(ffi.Pointer<tarantool_message_loop_configuration_t>)>();

  void tarantool_message_loop_start(
    ffi.Pointer<tarantool_message_loop_configuration_t> configuration,
  ) {
    return _tarantool_message_loop_start(
      configuration,
    );
  }

  late final _tarantool_message_loop_startPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<tarantool_message_loop_configuration_t>)>>(
      'tarantool_message_loop_start');
  late final _tarantool_message_loop_start =
      _tarantool_message_loop_startPtr.asFunction<
          void Function(ffi.Pointer<tarantool_message_loop_configuration_t>)>();

  void tarantool_message_loop_stop() {
    return _tarantool_message_loop_stop();
  }

  late final _tarantool_message_loop_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'tarantool_message_loop_stop');
  late final _tarantool_message_loop_stop =
      _tarantool_message_loop_stopPtr.asFunction<void Function()>();

  bool tarantool_message_loop_active() {
    return _tarantool_message_loop_active();
  }

  late final _tarantool_message_loop_activePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'tarantool_message_loop_active');
  late final _tarantool_message_loop_active =
      _tarantool_message_loop_activePtr.asFunction<bool Function()>();

  bool tarantool_send_message(
    ffi.Pointer<tarantool_message_t> message,
    Object callback,
  ) {
    return _tarantool_send_message(
      message,
      callback,
    );
  }

  late final _tarantool_send_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<tarantool_message_t>,
              ffi.Handle)>>('tarantool_send_message');
  late final _tarantool_send_message = _tarantool_send_messagePtr
      .asFunction<bool Function(ffi.Pointer<tarantool_message_t>, Object)>();

  ffi.Pointer<ffi.Void> tarantool_tuple_allocate(
    int size,
  ) {
    return _tarantool_tuple_allocate(
      size,
    );
  }

  late final _tarantool_tuple_allocatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'tarantool_tuple_allocate');
  late final _tarantool_tuple_allocate = _tarantool_tuple_allocatePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_tuple_new(
    ffi.Pointer<ffi.Char> data,
    int size,
  ) {
    return _tarantool_tuple_new(
      data,
      size,
    );
  }

  late final _tarantool_tuple_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('tarantool_tuple_new');
  late final _tarantool_tuple_new = _tarantool_tuple_newPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(ffi.Pointer<ffi.Char>, int)>();

  void tarantool_tuple_free(
    ffi.Pointer<tarantool_tuple_t> tuple,
  ) {
    return _tarantool_tuple_free(
      tuple,
    );
  }

  late final _tarantool_tuple_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<tarantool_tuple_t>)>>('tarantool_tuple_free');
  late final _tarantool_tuple_free = _tarantool_tuple_freePtr
      .asFunction<void Function(ffi.Pointer<tarantool_tuple_t>)>();

  ffi.Pointer<obuf> tarantool_output_buffer() {
    return _tarantool_output_buffer();
  }

  late final _tarantool_output_bufferPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<obuf> Function()>>(
          'tarantool_output_buffer');
  late final _tarantool_output_buffer =
      _tarantool_output_bufferPtr.asFunction<ffi.Pointer<obuf> Function()>();

  Object dart_get_handle_from_message(
    ffi.Pointer<tarantool_message_t> message,
  ) {
    return _dart_get_handle_from_message(
      message,
    );
  }

  late final _dart_get_handle_from_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<tarantool_message_t>)>>(
      'dart_get_handle_from_message');
  late final _dart_get_handle_from_message = _dart_get_handle_from_messagePtr
      .asFunction<Object Function(ffi.Pointer<tarantool_message_t>)>();

  void dart_delete_handle_from_message(
    ffi.Pointer<tarantool_message_t> message,
  ) {
    return _dart_delete_handle_from_message(
      message,
    );
  }

  late final _dart_delete_handle_from_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<tarantool_message_t>)>>(
      'dart_delete_handle_from_message');
  late final _dart_delete_handle_from_message =
      _dart_delete_handle_from_messagePtr
          .asFunction<void Function(ffi.Pointer<tarantool_message_t>)>();

  void tarantool_initialize_box(
    int output_buffer_capacity,
  ) {
    return _tarantool_initialize_box(
      output_buffer_capacity,
    );
  }

  late final _tarantool_initialize_boxPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Size)>>(
          'tarantool_initialize_box');
  late final _tarantool_initialize_box =
      _tarantool_initialize_boxPtr.asFunction<void Function(int)>();

  void tarantool_destroy_box() {
    return _tarantool_destroy_box();
  }

  late final _tarantool_destroy_boxPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tarantool_destroy_box');
  late final _tarantool_destroy_box =
      _tarantool_destroy_boxPtr.asFunction<void Function()>();

  int tarantool_evaluate(
    ffi.Pointer<ffi.Char> script,
  ) {
    return _tarantool_evaluate(
      script,
    );
  }

  late final _tarantool_evaluatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'tarantool_evaluate');
  late final _tarantool_evaluate =
      _tarantool_evaluatePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_call(
    ffi.Pointer<tarantool_call_request_t> request,
  ) {
    return _tarantool_call(
      request,
    );
  }

  late final _tarantool_callPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_call_request_t>)>>('tarantool_call');
  late final _tarantool_call = _tarantool_callPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_call_request_t>)>();

  ffi.Pointer<ffi.Char> tarantool_status() {
    return _tarantool_status();
  }

  late final _tarantool_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'tarantool_status');
  late final _tarantool_status =
      _tarantool_statusPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  bool tarantool_is_read_only() {
    return _tarantool_is_read_only();
  }

  late final _tarantool_is_read_onlyPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'tarantool_is_read_only');
  late final _tarantool_is_read_only =
      _tarantool_is_read_onlyPtr.asFunction<bool Function()>();

  int tarantool_begin() {
    return _tarantool_begin();
  }

  late final _tarantool_beginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('tarantool_begin');
  late final _tarantool_begin =
      _tarantool_beginPtr.asFunction<int Function()>();

  int tarantool_commit() {
    return _tarantool_commit();
  }

  late final _tarantool_commitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('tarantool_commit');
  late final _tarantool_commit =
      _tarantool_commitPtr.asFunction<int Function()>();

  int tarantool_rollback() {
    return _tarantool_rollback();
  }

  late final _tarantool_rollbackPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('tarantool_rollback');
  late final _tarantool_rollback =
      _tarantool_rollbackPtr.asFunction<int Function()>();

  bool tarantool_in_transaction() {
    return _tarantool_in_transaction();
  }

  late final _tarantool_in_transactionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'tarantool_in_transaction');
  late final _tarantool_in_transaction =
      _tarantool_in_transactionPtr.asFunction<bool Function()>();

  int tarantool_space_iterator(
    ffi.Pointer<tarantool_space_iterator_request_t> request,
  ) {
    return _tarantool_space_iterator(
      request,
    );
  }

  late final _tarantool_space_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.IntPtr Function(
                  ffi.Pointer<tarantool_space_iterator_request_t>)>>(
      'tarantool_space_iterator');
  late final _tarantool_space_iterator =
      _tarantool_space_iteratorPtr.asFunction<
          int Function(ffi.Pointer<tarantool_space_iterator_request_t>)>();

  int tarantool_space_count(
    ffi.Pointer<tarantool_space_count_request_t> request,
  ) {
    return _tarantool_space_count(
      request,
    );
  }

  late final _tarantool_space_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<tarantool_space_count_request_t>)>>(
      'tarantool_space_count');
  late final _tarantool_space_count = _tarantool_space_countPtr
      .asFunction<int Function(ffi.Pointer<tarantool_space_count_request_t>)>();

  int tarantool_space_length(
    int id,
  ) {
    return _tarantool_space_length(
      id,
    );
  }

  late final _tarantool_space_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint32)>>(
          'tarantool_space_length');
  late final _tarantool_space_length =
      _tarantool_space_lengthPtr.asFunction<int Function(int)>();

  void tarantool_space_truncate(
    int id,
  ) {
    return _tarantool_space_truncate(
      id,
    );
  }

  late final _tarantool_space_truncatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>(
          'tarantool_space_truncate');
  late final _tarantool_space_truncate =
      _tarantool_space_truncatePtr.asFunction<void Function(int)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_put(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_put(
      request,
    );
  }

  late final _tarantool_space_putPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_space_request_t>)>>('tarantool_space_put');
  late final _tarantool_space_put = _tarantool_space_putPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_insert(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_insert(
      request,
    );
  }

  late final _tarantool_space_insertPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>(
      'tarantool_space_insert');
  late final _tarantool_space_insert = _tarantool_space_insertPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_update(
    ffi.Pointer<tarantool_space_update_request_t> request,
  ) {
    return _tarantool_space_update(
      request,
    );
  }

  late final _tarantool_space_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_update_request_t>)>>(
      'tarantool_space_update');
  late final _tarantool_space_update = _tarantool_space_updatePtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_update_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_upsert(
    ffi.Pointer<tarantool_space_upsert_request_t> request,
  ) {
    return _tarantool_space_upsert(
      request,
    );
  }

  late final _tarantool_space_upsertPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_upsert_request_t>)>>(
      'tarantool_space_upsert');
  late final _tarantool_space_upsert = _tarantool_space_upsertPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_upsert_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_get(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_get(
      request,
    );
  }

  late final _tarantool_space_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_space_request_t>)>>('tarantool_space_get');
  late final _tarantool_space_get = _tarantool_space_getPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_min(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_min(
      request,
    );
  }

  late final _tarantool_space_minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_space_request_t>)>>('tarantool_space_min');
  late final _tarantool_space_min = _tarantool_space_minPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_max(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_max(
      request,
    );
  }

  late final _tarantool_space_maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_space_request_t>)>>('tarantool_space_max');
  late final _tarantool_space_max = _tarantool_space_maxPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_select(
    ffi.Pointer<tarantool_space_select_request_t> request,
  ) {
    return _tarantool_space_select(
      request,
    );
  }

  late final _tarantool_space_selectPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_select_request_t>)>>(
      'tarantool_space_select');
  late final _tarantool_space_select = _tarantool_space_selectPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_select_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_space_delete(
    ffi.Pointer<tarantool_space_request_t> request,
  ) {
    return _tarantool_space_delete(
      request,
    );
  }

  late final _tarantool_space_deletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>(
      'tarantool_space_delete');
  late final _tarantool_space_delete = _tarantool_space_deletePtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_space_request_t>)>();

  int tarantool_space_id_by_name(
    ffi.Pointer<tarantool_space_id_request_t> request,
  ) {
    return _tarantool_space_id_by_name(
      request,
    );
  }

  late final _tarantool_space_id_by_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<tarantool_space_id_request_t>)>>(
      'tarantool_space_id_by_name');
  late final _tarantool_space_id_by_name = _tarantool_space_id_by_namePtr
      .asFunction<int Function(ffi.Pointer<tarantool_space_id_request_t>)>();

  int tarantool_index_iterator(
    ffi.Pointer<tarantool_index_iterator_request_t> request,
  ) {
    return _tarantool_index_iterator(
      request,
    );
  }

  late final _tarantool_index_iteratorPtr = _lookup<
          ffi.NativeFunction<
              ffi.IntPtr Function(
                  ffi.Pointer<tarantool_index_iterator_request_t>)>>(
      'tarantool_index_iterator');
  late final _tarantool_index_iterator =
      _tarantool_index_iteratorPtr.asFunction<
          int Function(ffi.Pointer<tarantool_index_iterator_request_t>)>();

  int tarantool_index_count(
    ffi.Pointer<tarantool_index_count_request_t> request,
  ) {
    return _tarantool_index_count(
      request,
    );
  }

  late final _tarantool_index_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<tarantool_index_count_request_t>)>>(
      'tarantool_index_count');
  late final _tarantool_index_count = _tarantool_index_countPtr
      .asFunction<int Function(ffi.Pointer<tarantool_index_count_request_t>)>();

  int tarantool_index_length(
    ffi.Pointer<tarantool_index_id_t> id,
  ) {
    return _tarantool_index_length(
      id,
    );
  }

  late final _tarantool_index_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              ffi.Pointer<tarantool_index_id_t>)>>('tarantool_index_length');
  late final _tarantool_index_length = _tarantool_index_lengthPtr
      .asFunction<int Function(ffi.Pointer<tarantool_index_id_t>)>();

  int tarantool_index_id_by_name(
    ffi.Pointer<tarantool_index_id_request_t> request,
  ) {
    return _tarantool_index_id_by_name(
      request,
    );
  }

  late final _tarantool_index_id_by_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<tarantool_index_id_request_t>)>>(
      'tarantool_index_id_by_name');
  late final _tarantool_index_id_by_name = _tarantool_index_id_by_namePtr
      .asFunction<int Function(ffi.Pointer<tarantool_index_id_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_index_get(
    ffi.Pointer<tarantool_index_request_t> request,
  ) {
    return _tarantool_index_get(
      request,
    );
  }

  late final _tarantool_index_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_index_request_t>)>>('tarantool_index_get');
  late final _tarantool_index_get = _tarantool_index_getPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_index_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_index_min(
    ffi.Pointer<tarantool_index_request_t> request,
  ) {
    return _tarantool_index_min(
      request,
    );
  }

  late final _tarantool_index_minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_index_request_t>)>>('tarantool_index_min');
  late final _tarantool_index_min = _tarantool_index_minPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_index_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_index_max(
    ffi.Pointer<tarantool_index_request_t> request,
  ) {
    return _tarantool_index_max(
      request,
    );
  }

  late final _tarantool_index_maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_index_request_t>)>>('tarantool_index_max');
  late final _tarantool_index_max = _tarantool_index_maxPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_index_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_index_select(
    ffi.Pointer<tarantool_index_select_request_t> request,
  ) {
    return _tarantool_index_select(
      request,
    );
  }

  late final _tarantool_index_selectPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_select_request_t>)>>(
      'tarantool_index_select');
  late final _tarantool_index_select = _tarantool_index_selectPtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_index_select_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_index_update(
    ffi.Pointer<tarantool_index_update_request_t> request,
  ) {
    return _tarantool_index_update(
      request,
    );
  }

  late final _tarantool_index_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_update_request_t>)>>(
      'tarantool_index_update');
  late final _tarantool_index_update = _tarantool_index_updatePtr.asFunction<
      ffi.Pointer<tarantool_tuple_t> Function(
          ffi.Pointer<tarantool_index_update_request_t>)>();

  ffi.Pointer<tarantool_tuple_t> tarantool_iterator_next(
    int iterator,
  ) {
    return _tarantool_iterator_next(
      iterator,
    );
  }

  late final _tarantool_iterator_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.IntPtr)>>('tarantool_iterator_next');
  late final _tarantool_iterator_next = _tarantool_iterator_nextPtr
      .asFunction<ffi.Pointer<tarantool_tuple_t> Function(int)>();

  void tarantool_iterator_destroy(
    int iterator,
  ) {
    return _tarantool_iterator_destroy(
      iterator,
    );
  }

  late final _tarantool_iterator_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.IntPtr)>>(
          'tarantool_iterator_destroy');
  late final _tarantool_iterator_destroy =
      _tarantool_iterator_destroyPtr.asFunction<void Function(int)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final TarantoolBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<intmax_t Function(intmax_t)>> get imaxabs =>
      _library._imaxabsPtr;
  ffi.Pointer<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>
      get imaxdiv => _library._imaxdivPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          intmax_t Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int)>> get strtoimax => _library._strtoimaxPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          uintmax_t Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int)>> get strtoumax => _library._strtoumaxPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          intmax_t Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Int)>> get wcstoimax => _library._wcstoimaxPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          uintmax_t Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Int)>> get wcstoumax => _library._wcstoumaxPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsError => _library._Dart_IsErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsApiError => _library._Dart_IsApiErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsUnhandledExceptionError =>
          _library._Dart_IsUnhandledExceptionErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsCompilationError => _library._Dart_IsCompilationErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsFatalError => _library._Dart_IsFatalErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>
      get Dart_GetError => _library._Dart_GetErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_ErrorHasException => _library._Dart_ErrorHasExceptionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ErrorGetException => _library._Dart_ErrorGetExceptionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ErrorGetStackTrace => _library._Dart_ErrorGetStackTracePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>
      get Dart_NewApiError => _library._Dart_NewApiErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>
      get Dart_NewCompilationError => _library._Dart_NewCompilationErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_NewUnhandledExceptionError =>
          _library._Dart_NewUnhandledExceptionErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>
      get Dart_PropagateError => _library._Dart_PropagateErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ToString => _library._Dart_ToStringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle, ffi.Handle)>>
      get Dart_IdentityEquals => _library._Dart_IdentityEqualsPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_HandleFromPersistent => _library._Dart_HandleFromPersistentPtr;
  ffi.Pointer<
          ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>
      get Dart_HandleFromWeakPersistent =>
          _library._Dart_HandleFromWeakPersistentPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_NewPersistentHandle => _library._Dart_NewPersistentHandlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>
      get Dart_SetPersistentHandle => _library._Dart_SetPersistentHandlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>
      get Dart_DeletePersistentHandle =>
          _library._Dart_DeletePersistentHandlePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          Dart_WeakPersistentHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>> get Dart_NewWeakPersistentHandle =>
      _library._Dart_NewWeakPersistentHandlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>
      get Dart_DeleteWeakPersistentHandle =>
          _library._Dart_DeleteWeakPersistentHandlePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(Dart_WeakPersistentHandle, ffi.IntPtr)>>
      get Dart_UpdateExternalSize => _library._Dart_UpdateExternalSizePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          Dart_FinalizableHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>> get Dart_NewFinalizableHandle =>
      _library._Dart_NewFinalizableHandlePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(Dart_FinalizableHandle, ffi.Handle)>>
      get Dart_DeleteFinalizableHandle =>
          _library._Dart_DeleteFinalizableHandlePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  Dart_FinalizableHandle, ffi.Handle, ffi.IntPtr)>>
      get Dart_UpdateFinalizableExternalSize =>
          _library._Dart_UpdateFinalizableExternalSizePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get Dart_VersionString => _library._Dart_VersionStringPtr;
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Dart_IsolateFlags>)>>
      get Dart_IsolateFlagsInitialize =>
          _library._Dart_IsolateFlagsInitializePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Dart_InitializeParams>)>> get Dart_Initialize =>
      _library._Dart_InitializePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get Dart_Cleanup => _library._Dart_CleanupPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_SetVMFlags => _library._Dart_SetVMFlagsPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>
      get Dart_IsVMFlagSet => _library._Dart_IsVMFlagSetPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_CreateIsolateGroup => _library._Dart_CreateIsolateGroupPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  Dart_Isolate,
                  ffi.Pointer<ffi.Char>,
                  Dart_IsolateShutdownCallback,
                  Dart_IsolateCleanupCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_CreateIsolateInGroup => _library._Dart_CreateIsolateInGroupPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.IntPtr,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_CreateIsolateGroupFromKernel =>
          _library._Dart_CreateIsolateGroupFromKernelPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_ShutdownIsolate => _library._Dart_ShutdownIsolatePtr;
  ffi.Pointer<ffi.NativeFunction<Dart_Isolate Function()>>
      get Dart_CurrentIsolate => _library._Dart_CurrentIsolatePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>
      get Dart_CurrentIsolateData => _library._Dart_CurrentIsolateDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>
      get Dart_IsolateData => _library._Dart_IsolateDataPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_IsolateGroup Function()>>
      get Dart_CurrentIsolateGroup => _library._Dart_CurrentIsolateGroupPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>
      get Dart_CurrentIsolateGroupData =>
          _library._Dart_CurrentIsolateGroupDataPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_IsolateGroupId Function()>>
      get Dart_CurrentIsolateGroupId => _library._Dart_CurrentIsolateGroupIdPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>
      get Dart_IsolateGroupData => _library._Dart_IsolateGroupDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_DebugName =>
      _library._Dart_DebugNamePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>
      get Dart_IsolateServiceId => _library._Dart_IsolateServiceIdPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>
      get Dart_EnterIsolate => _library._Dart_EnterIsolatePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>
      get Dart_KillIsolate => _library._Dart_KillIsolatePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>
      get Dart_NotifyIdle => _library._Dart_NotifyIdlePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> get Dart_NotifyDetach =>
      _library._Dart_NotifyDetachPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_NotifyLowMemory => _library._Dart_NotifyLowMemoryPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>
      get Dart_SetPerformanceMode => _library._Dart_SetPerformanceModePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_StartProfiling => _library._Dart_StartProfilingPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> get Dart_StopProfiling =>
      _library._Dart_StopProfilingPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_ThreadDisableProfiling =>
          _library._Dart_ThreadDisableProfilingPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_ThreadEnableProfiling => _library._Dart_ThreadEnableProfilingPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, ffi.IntPtr)>>
      get Dart_AddSymbols => _library._Dart_AddSymbolsPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> get Dart_ExitIsolate =>
      _library._Dart_ExitIsolatePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Bool)>> get Dart_CreateSnapshot =>
      _library._Dart_CreateSnapshotPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_IsKernel => _library._Dart_IsKernelPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>
      get Dart_IsolateMakeRunnable => _library._Dart_IsolateMakeRunnablePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_MessageNotifyCallback)>>
      get Dart_SetMessageNotifyCallback =>
          _library._Dart_SetMessageNotifyCallbackPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_MessageNotifyCallback Function()>>
      get Dart_GetMessageNotifyCallback =>
          _library._Dart_GetMessageNotifyCallbackPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_ShouldPauseOnStart => _library._Dart_ShouldPauseOnStartPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>
      get Dart_SetShouldPauseOnStart => _library._Dart_SetShouldPauseOnStartPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_IsPausedOnStart => _library._Dart_IsPausedOnStartPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>
      get Dart_SetPausedOnStart => _library._Dart_SetPausedOnStartPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_ShouldPauseOnExit => _library._Dart_ShouldPauseOnExitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>
      get Dart_SetShouldPauseOnExit => _library._Dart_SetShouldPauseOnExitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_IsPausedOnExit => _library._Dart_IsPausedOnExitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>
      get Dart_SetPausedOnExit => _library._Dart_SetPausedOnExitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>
      get Dart_SetStickyError => _library._Dart_SetStickyErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_HasStickyError => _library._Dart_HasStickyErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>
      get Dart_GetStickyError => _library._Dart_GetStickyErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>
      get Dart_HandleMessage => _library._Dart_HandleMessagePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>
      get Dart_WaitForEvent => _library._Dart_WaitForEventPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_HandleServiceMessages => _library._Dart_HandleServiceMessagesPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_HasServiceMessages => _library._Dart_HasServiceMessagesPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_RunLoop =>
      _library._Dart_RunLoopPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Bool, Dart_Port, Dart_Port,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>> get Dart_RunLoopAsync =>
      _library._Dart_RunLoopAsyncPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_Port Function()>>
      get Dart_GetMainPortId => _library._Dart_GetMainPortIdPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>> get Dart_HasLivePorts =>
      _library._Dart_HasLivePortsPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Handle)>>
      get Dart_Post => _library._Dart_PostPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_Port)>>
      get Dart_NewSendPort => _library._Dart_NewSendPortPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<Dart_Port>)>>
      get Dart_SendPortGetId => _library._Dart_SendPortGetIdPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> get Dart_EnterScope =>
      _library._Dart_EnterScopePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> get Dart_ExitScope =>
      _library._Dart_ExitScopePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr)>>
      get Dart_ScopeAllocate => _library._Dart_ScopeAllocatePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_Null =>
      _library._Dart_NullPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsNull => _library._Dart_IsNullPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_EmptyString =>
      _library._Dart_EmptyStringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_TypeDynamic =>
      _library._Dart_TypeDynamicPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_TypeVoid =>
      _library._Dart_TypeVoidPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_TypeNever =>
      _library._Dart_TypeNeverPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_ObjectEquals => _library._Dart_ObjectEqualsPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_ObjectIsType => _library._Dart_ObjectIsTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsInstance => _library._Dart_IsInstancePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsNumber => _library._Dart_IsNumberPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsInteger => _library._Dart_IsIntegerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsDouble => _library._Dart_IsDoublePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsBoolean => _library._Dart_IsBooleanPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsString => _library._Dart_IsStringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsStringLatin1 => _library._Dart_IsStringLatin1Ptr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsExternalString => _library._Dart_IsExternalStringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsList => _library._Dart_IsListPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsMap => _library._Dart_IsMapPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsLibrary => _library._Dart_IsLibraryPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsType => _library._Dart_IsTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsFunction => _library._Dart_IsFunctionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsVariable => _library._Dart_IsVariablePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsTypeVariable => _library._Dart_IsTypeVariablePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsClosure => _library._Dart_IsClosurePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsTypedData => _library._Dart_IsTypedDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsByteBuffer => _library._Dart_IsByteBufferPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsFuture => _library._Dart_IsFuturePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_InstanceGetType => _library._Dart_InstanceGetTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ClassName => _library._Dart_ClassNamePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_FunctionName => _library._Dart_FunctionNamePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_FunctionOwner => _library._Dart_FunctionOwnerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_FunctionIsStatic => _library._Dart_FunctionIsStaticPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>
      get Dart_IsTearOff => _library._Dart_IsTearOffPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ClosureFunction => _library._Dart_ClosureFunctionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ClassLibrary => _library._Dart_ClassLibraryPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_IntegerFitsIntoInt64 => _library._Dart_IntegerFitsIntoInt64Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_IntegerFitsIntoUint64 => _library._Dart_IntegerFitsIntoUint64Ptr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>
      get Dart_NewInteger => _library._Dart_NewIntegerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Uint64)>>
      get Dart_NewIntegerFromUint64 => _library._Dart_NewIntegerFromUint64Ptr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>
      get Dart_NewIntegerFromHexCString =>
          _library._Dart_NewIntegerFromHexCStringPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Int64>)>>
      get Dart_IntegerToInt64 => _library._Dart_IntegerToInt64Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint64>)>>
      get Dart_IntegerToUint64 => _library._Dart_IntegerToUint64Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_IntegerToHexCString => _library._Dart_IntegerToHexCStringPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Double)>>
      get Dart_NewDouble => _library._Dart_NewDoublePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Double>)>>
      get Dart_DoubleValue => _library._Dart_DoubleValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Handle)>>
      get Dart_GetStaticMethodClosure =>
          _library._Dart_GetStaticMethodClosurePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_True =>
      _library._Dart_TruePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_False =>
      _library._Dart_FalsePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>
      get Dart_NewBoolean => _library._Dart_NewBooleanPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_BooleanValue => _library._Dart_BooleanValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_StringLength => _library._Dart_StringLengthPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>
      get Dart_NewStringFromCString => _library._Dart_NewStringFromCStringPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_NewStringFromUTF8 => _library._Dart_NewStringFromUTF8Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<ffi.Uint16>, ffi.IntPtr)>>
      get Dart_NewStringFromUTF16 => _library._Dart_NewStringFromUTF16Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<ffi.Int32>, ffi.IntPtr)>>
      get Dart_NewStringFromUTF32 => _library._Dart_NewStringFromUTF32Ptr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>> get Dart_NewExternalLatin1String =>
      _library._Dart_NewExternalLatin1StringPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>> get Dart_NewExternalUTF16String =>
      _library._Dart_NewExternalUTF16StringPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_StringToCString => _library._Dart_StringToCStringPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_StringToUTF8 =>
      _library._Dart_StringToUTF8Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_StringToLatin1 => _library._Dart_StringToLatin1Ptr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_StringToUTF16 =>
      _library._Dart_StringToUTF16Ptr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_StringStorageSize => _library._Dart_StringStorageSizePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.IntPtr>,
                  ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>
      get Dart_StringGetProperties => _library._Dart_StringGetPropertiesPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>
      get Dart_NewList => _library._Dart_NewListPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>
      get Dart_NewListOf => _library._Dart_NewListOfPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>
      get Dart_NewListOfType => _library._Dart_NewListOfTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr)>>
      get Dart_NewListOfTypeFilled => _library._Dart_NewListOfTypeFilledPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_ListLength => _library._Dart_ListLengthPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>
      get Dart_ListGetAt => _library._Dart_ListGetAtPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.IntPtr, ffi.IntPtr, ffi.Pointer<ffi.Handle>)>>
      get Dart_ListGetRange => _library._Dart_ListGetRangePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Handle)>>
      get Dart_ListSetAt => _library._Dart_ListSetAtPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_ListGetAsBytes => _library._Dart_ListGetAsBytesPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_ListSetAsBytes => _library._Dart_ListSetAsBytesPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_MapGetAt => _library._Dart_MapGetAtPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_MapContainsKey => _library._Dart_MapContainsKeyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_MapKeys => _library._Dart_MapKeysPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>
      get Dart_GetTypeOfTypedData => _library._Dart_GetTypeOfTypedDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>
      get Dart_GetTypeOfExternalTypedData =>
          _library._Dart_GetTypeOfExternalTypedDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>
      get Dart_NewTypedData => _library._Dart_NewTypedDataPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Int32, ffi.Pointer<ffi.Void>, ffi.IntPtr)>>
      get Dart_NewExternalTypedData => _library._Dart_NewExternalTypedDataPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>, ffi.IntPtr,
                  ffi.Pointer<ffi.Void>, ffi.IntPtr, Dart_HandleFinalizer)>>
      get Dart_NewExternalTypedDataWithFinalizer =>
          _library._Dart_NewExternalTypedDataWithFinalizerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>, ffi.IntPtr,
                  ffi.Pointer<ffi.Void>, ffi.IntPtr, Dart_HandleFinalizer)>>
      get Dart_NewUnmodifiableExternalTypedDataWithFinalizer =>
          _library._Dart_NewUnmodifiableExternalTypedDataWithFinalizerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_NewByteBuffer => _library._Dart_NewByteBufferPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_TypedDataAcquireData =>
      _library._Dart_TypedDataAcquireDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_TypedDataReleaseData => _library._Dart_TypedDataReleaseDataPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_GetDataFromByteBuffer => _library._Dart_GetDataFromByteBufferPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.Int, ffi.Pointer<ffi.Handle>)>>
      get Dart_New => _library._Dart_NewPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_Allocate => _library._Dart_AllocatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_AllocateWithNativeFields =>
          _library._Dart_AllocateWithNativeFieldsPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.Int, ffi.Pointer<ffi.Handle>)>>
      get Dart_Invoke => _library._Dart_InvokePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Int, ffi.Pointer<ffi.Handle>)>>
      get Dart_InvokeClosure => _library._Dart_InvokeClosurePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.Int, ffi.Pointer<ffi.Handle>)>>
      get Dart_InvokeConstructor => _library._Dart_InvokeConstructorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_GetField => _library._Dart_GetFieldPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Handle)>>
      get Dart_SetField => _library._Dart_SetFieldPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_ThrowException => _library._Dart_ThrowExceptionPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_ReThrowException => _library._Dart_ReThrowExceptionPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Int>)>>
      get Dart_GetNativeInstanceFieldCount =>
          _library._Dart_GetNativeInstanceFieldCountPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Int, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_GetNativeInstanceField =>
          _library._Dart_GetNativeInstanceFieldPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Int, ffi.IntPtr)>>
      get Dart_SetNativeInstanceField =>
          _library._Dart_SetNativeInstanceFieldPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(Dart_NativeArguments)>>
      get Dart_GetNativeIsolateGroupData =>
          _library._Dart_GetNativeIsolateGroupDataPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments,
                  ffi.Int,
                  ffi.Pointer<Dart_NativeArgument_Descriptor>,
                  ffi.Pointer<Dart_NativeArgument_Value>)>>
      get Dart_GetNativeArguments => _library._Dart_GetNativeArgumentsPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int)>>
      get Dart_GetNativeArgument => _library._Dart_GetNativeArgumentPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function(Dart_NativeArguments)>>
      get Dart_GetNativeArgumentCount =>
          _library._Dart_GetNativeArgumentCountPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_GetNativeFieldsOfArgument =>
      _library._Dart_GetNativeFieldsOfArgumentPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments, ffi.Pointer<ffi.IntPtr>)>>
      get Dart_GetNativeReceiver => _library._Dart_GetNativeReceiverPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>
      get Dart_GetNativeStringArgument =>
          _library._Dart_GetNativeStringArgumentPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments, ffi.Int, ffi.Pointer<ffi.Int64>)>>
      get Dart_GetNativeIntegerArgument =>
          _library._Dart_GetNativeIntegerArgumentPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments, ffi.Int, ffi.Pointer<ffi.Bool>)>>
      get Dart_GetNativeBooleanArgument =>
          _library._Dart_GetNativeBooleanArgumentPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments, ffi.Int, ffi.Pointer<ffi.Double>)>>
      get Dart_GetNativeDoubleArgument =>
          _library._Dart_GetNativeDoubleArgumentPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(Dart_NativeArguments, ffi.Handle)>>
      get Dart_SetReturnValue => _library._Dart_SetReturnValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  Dart_NativeArguments, Dart_WeakPersistentHandle)>>
      get Dart_SetWeakHandleReturnValue =>
          _library._Dart_SetWeakHandleReturnValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(Dart_NativeArguments, ffi.Bool)>>
      get Dart_SetBooleanReturnValue => _library._Dart_SetBooleanReturnValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(Dart_NativeArguments, ffi.Int64)>>
      get Dart_SetIntegerReturnValue => _library._Dart_SetIntegerReturnValuePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(Dart_NativeArguments, ffi.Double)>>
      get Dart_SetDoubleReturnValue => _library._Dart_SetDoubleReturnValuePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_EnvironmentCallback)>>
      get Dart_SetEnvironmentCallback =>
          _library._Dart_SetEnvironmentCallbackPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, Dart_NativeEntryResolver,
              Dart_NativeEntrySymbol)>> get Dart_SetNativeResolver =>
      _library._Dart_SetNativeResolverPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntryResolver>)>>
      get Dart_GetNativeResolver => _library._Dart_GetNativeResolverPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntrySymbol>)>>
      get Dart_GetNativeSymbol => _library._Dart_GetNativeSymbolPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, Dart_FfiNativeResolver)>>
      get Dart_SetFfiNativeResolver => _library._Dart_SetFfiNativeResolverPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_LibraryTagHandler)>>
      get Dart_SetLibraryTagHandler => _library._Dart_SetLibraryTagHandlerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_DeferredLoadHandler)>>
      get Dart_SetDeferredLoadHandler =>
          _library._Dart_SetDeferredLoadHandlerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.IntPtr, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>>
      get Dart_DeferredLoadComplete => _library._Dart_DeferredLoadCompletePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Char>, ffi.Bool)>>
      get Dart_DeferredLoadCompleteError =>
          _library._Dart_DeferredLoadCompleteErrorPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_DefaultCanonicalizeUrl =>
          _library._Dart_DefaultCanonicalizeUrlPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_LoadScriptFromKernel => _library._Dart_LoadScriptFromKernelPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_RootLibrary =>
      _library._Dart_RootLibraryPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_SetRootLibrary => _library._Dart_SetRootLibraryPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Handle>)>>
      get Dart_GetType => _library._Dart_GetTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Handle>)>>
      get Dart_GetNullableType => _library._Dart_GetNullableTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Handle>)>>
      get Dart_GetNonNullableType => _library._Dart_GetNonNullableTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_TypeToNullableType => _library._Dart_TypeToNullableTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_TypeToNonNullableType => _library._Dart_TypeToNonNullableTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_IsNullableType => _library._Dart_IsNullableTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_IsNonNullableType => _library._Dart_IsNonNullableTypePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Bool>)>>
      get Dart_IsLegacyType => _library._Dart_IsLegacyTypePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_GetClass => _library._Dart_GetClassPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_LibraryUrl => _library._Dart_LibraryUrlPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_LibraryResolvedUrl => _library._Dart_LibraryResolvedUrlPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>
      get Dart_GetLoadedLibraries => _library._Dart_GetLoadedLibrariesPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>
      get Dart_LookupLibrary => _library._Dart_LookupLibraryPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>
      get Dart_LibraryHandleError => _library._Dart_LibraryHandleErrorPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_LoadLibraryFromKernel => _library._Dart_LoadLibraryFromKernelPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>
      get Dart_FinalizeLoading => _library._Dart_FinalizeLoadingPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>
      get Dart_GetPeer => _library._Dart_GetPeerPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Void>)>>
      get Dart_SetPeer => _library._Dart_SetPeerPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>
      get Dart_IsKernelIsolate => _library._Dart_IsKernelIsolatePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_KernelIsolateIsRunning =>
          _library._Dart_KernelIsolateIsRunningPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_Port Function()>> get Dart_KernelPort =>
      _library._Dart_KernelPortPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>> get Dart_CompileToKernel =>
      _library._Dart_CompileToKernelPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Int32)>> get Dart_CompileToKernelWithGivenNullsafety =>
      _library._Dart_CompileToKernelWithGivenNullsafetyPtr;
  ffi.Pointer<ffi.NativeFunction<Dart_KernelCompilationResult Function()>>
      get Dart_KernelListDependencies =>
          _library._Dart_KernelListDependenciesPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>
      get Dart_SetDartLibrarySourcesKernel =>
          _library._Dart_SetDartLibrarySourcesKernelPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>> get Dart_DetectNullSafety =>
      _library._Dart_DetectNullSafetyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>
      get Dart_IsServiceIsolate => _library._Dart_IsServiceIsolatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(Dart_Port, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>
      get Dart_WriteProfileToTimeline =>
          _library._Dart_WriteProfileToTimelinePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_Precompile =>
      _library._Dart_PrecompilePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>
      get Dart_LoadingUnitLibraryUris =>
          _library._Dart_LoadingUnitLibraryUrisPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_StreamingWriteCallback,
                  ffi.Pointer<ffi.Void>, ffi.Bool, ffi.Pointer<ffi.Void>)>>
      get Dart_CreateAppAOTSnapshotAsAssembly =>
          _library._Dart_CreateAppAOTSnapshotAsAssemblyPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>
      get Dart_CreateAppAOTSnapshotAsAssemblies =>
          _library._Dart_CreateAppAOTSnapshotAsAssembliesPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>> get Dart_CreateAppAOTSnapshotAsElf =>
      _library._Dart_CreateAppAOTSnapshotAsElfPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>
      get Dart_CreateAppAOTSnapshotAsElfs =>
          _library._Dart_CreateAppAOTSnapshotAsElfsPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>)>>
      get Dart_CreateVMAOTSnapshotAsAssembly =>
          _library._Dart_CreateVMAOTSnapshotAsAssemblyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>> get Dart_SortClasses =>
      _library._Dart_SortClassesPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_CreateAppJITSnapshotAsBlobs =>
      _library._Dart_CreateAppJITSnapshotAsBlobsPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<ffi.IntPtr>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<ffi.IntPtr>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<ffi.IntPtr>,
                  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
                  ffi.Pointer<ffi.IntPtr>)>>
      get Dart_CreateCoreJITSnapshotAsBlobs =>
          _library._Dart_CreateCoreJITSnapshotAsBlobsPtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>> get Dart_GetObfuscationMap =>
      _library._Dart_GetObfuscationMapPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get Dart_IsPrecompiledRuntime => _library._Dart_IsPrecompiledRuntimePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get Dart_DumpNativeStackTrace => _library._Dart_DumpNativeStackTracePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get Dart_PrepareToAbort => _library._Dart_PrepareToAbortPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.UnsignedInt Function()>>
      get tarantool_generate_owner_id =>
          _library._tarantool_generate_owner_idPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
                  ffi.Pointer<tarantool_configuration_t>)>>
      get tarantool_initialize => _library._tarantool_initializePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get tarantool_initialized => _library._tarantool_initializedPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      get tarantool_shutdown => _library._tarantool_shutdownPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<tarantool_message_loop_configuration_t>)>>
      get tarantool_message_loop_initialize =>
          _library._tarantool_message_loop_initializePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<tarantool_message_loop_configuration_t>)>>
      get tarantool_message_loop_start =>
          _library._tarantool_message_loop_startPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get tarantool_message_loop_stop =>
          _library._tarantool_message_loop_stopPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get tarantool_message_loop_active =>
          _library._tarantool_message_loop_activePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<tarantool_message_t>, ffi.Handle)>>
      get tarantool_send_message => _library._tarantool_send_messagePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>
      get tarantool_tuple_allocate => _library._tarantool_tuple_allocatePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>> get tarantool_tuple_new =>
      _library._tarantool_tuple_newPtr;
  ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<tarantool_tuple_t>)>>
      get tarantool_tuple_free => _library._tarantool_tuple_freePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<obuf> Function()>>
      get tarantool_output_buffer => _library._tarantool_output_bufferPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Handle Function(ffi.Pointer<tarantool_message_t>)>>
      get dart_get_handle_from_message =>
          _library._dart_get_handle_from_messagePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<tarantool_message_t>)>>
      get dart_delete_handle_from_message =>
          _library._dart_delete_handle_from_messagePtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Size)>>
      get tarantool_initialize_box => _library._tarantool_initialize_boxPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
      get tarantool_destroy_box => _library._tarantool_destroy_boxPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>
      get tarantool_evaluate => _library._tarantool_evaluatePtr;
  ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<tarantool_tuple_t> Function(
              ffi.Pointer<tarantool_call_request_t>)>> get tarantool_call =>
      _library._tarantool_callPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>
      get tarantool_status => _library._tarantool_statusPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get tarantool_is_read_only => _library._tarantool_is_read_onlyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function()>> get tarantool_begin =>
      _library._tarantool_beginPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function()>> get tarantool_commit =>
      _library._tarantool_commitPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Int Function()>> get tarantool_rollback =>
      _library._tarantool_rollbackPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Bool Function()>>
      get tarantool_in_transaction => _library._tarantool_in_transactionPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.IntPtr Function(
                  ffi.Pointer<tarantool_space_iterator_request_t>)>>
      get tarantool_space_iterator => _library._tarantool_space_iteratorPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<tarantool_space_count_request_t>)>>
      get tarantool_space_count => _library._tarantool_space_countPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint32)>>
      get tarantool_space_length => _library._tarantool_space_lengthPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint32)>>
      get tarantool_space_truncate => _library._tarantool_space_truncatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_put => _library._tarantool_space_putPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_insert => _library._tarantool_space_insertPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_update_request_t>)>>
      get tarantool_space_update => _library._tarantool_space_updatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_upsert_request_t>)>>
      get tarantool_space_upsert => _library._tarantool_space_upsertPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_get => _library._tarantool_space_getPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_min => _library._tarantool_space_minPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_max => _library._tarantool_space_maxPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_select_request_t>)>>
      get tarantool_space_select => _library._tarantool_space_selectPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_space_request_t>)>>
      get tarantool_space_delete => _library._tarantool_space_deletePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<tarantool_space_id_request_t>)>>
      get tarantool_space_id_by_name => _library._tarantool_space_id_by_namePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.IntPtr Function(
                  ffi.Pointer<tarantool_index_iterator_request_t>)>>
      get tarantool_index_iterator => _library._tarantool_index_iteratorPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint64 Function(
                  ffi.Pointer<tarantool_index_count_request_t>)>>
      get tarantool_index_count => _library._tarantool_index_countPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<tarantool_index_id_t>)>>
      get tarantool_index_length => _library._tarantool_index_lengthPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<tarantool_index_id_request_t>)>>
      get tarantool_index_id_by_name => _library._tarantool_index_id_by_namePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_request_t>)>>
      get tarantool_index_get => _library._tarantool_index_getPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_request_t>)>>
      get tarantool_index_min => _library._tarantool_index_minPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_request_t>)>>
      get tarantool_index_max => _library._tarantool_index_maxPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_select_request_t>)>>
      get tarantool_index_select => _library._tarantool_index_selectPtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(
                  ffi.Pointer<tarantool_index_update_request_t>)>>
      get tarantool_index_update => _library._tarantool_index_updatePtr;
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<tarantool_tuple_t> Function(ffi.IntPtr)>>
      get tarantool_iterator_next => _library._tarantool_iterator_nextPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.IntPtr)>>
      get tarantool_iterator_destroy => _library._tarantool_iterator_destroyPtr;
}

class imaxdiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

typedef intmax_t = ffi.Long;
typedef uintmax_t = ffi.UnsignedLong;
typedef Dart_WeakPersistentHandle = ffi.Pointer<_Dart_WeakPersistentHandle>;

class _Dart_WeakPersistentHandle extends ffi.Opaque {}

typedef Dart_HandleFinalizer = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;
typedef Dart_FinalizableHandle = ffi.Pointer<_Dart_FinalizableHandle>;

class _Dart_FinalizableHandle extends ffi.Opaque {}

class Dart_IsolateFlags extends ffi.Struct {
  @ffi.Int32()
  external int version;

  @ffi.Bool()
  external bool enable_asserts;

  @ffi.Bool()
  external bool use_field_guards;

  @ffi.Bool()
  external bool use_osr;

  @ffi.Bool()
  external bool obfuscate;

  @ffi.Bool()
  external bool load_vmservice_library;

  @ffi.Bool()
  external bool copy_parent_code;

  @ffi.Bool()
  external bool null_safety;

  @ffi.Bool()
  external bool is_system_isolate;

  @ffi.Bool()
  external bool snapshot_is_dontneed_safe;

  @ffi.Bool()
  external bool branch_coverage;
}

/// Forward declaration
class Dart_CodeObserver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external Dart_OnNewCodeCallback on_new_code;
}

/// Callback provided by the embedder that is used by the VM to notify on code
/// object creation, *before* it is invoked the first time.
/// This is useful for embedders wanting to e.g. keep track of PCs beyond
/// the lifetime of the garbage collected code objects.
/// Note that an address range may be used by more than one code object over the
/// lifecycle of a process. Clients of this function should record timestamps for
/// these compilation events and when collecting PCs to disambiguate reused
/// address ranges.
typedef Dart_OnNewCodeCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<Dart_CodeObserver>, ffi.Pointer<ffi.Char>,
            ffi.UintPtr, ffi.UintPtr)>>;

/// Describes how to initialize the VM. Used with Dart_Initialize.
class Dart_InitializeParams extends ffi.Struct {
  /// Identifies the version of the struct used by the client.
  /// should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  @ffi.Int32()
  external int version;

  /// A buffer containing snapshot data, or NULL if no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_data;

  /// A buffer containing a snapshot of precompiled instructions, or NULL if
  /// no snapshot is provided.
  ///
  /// If provided, the buffer must remain valid until Dart_Cleanup returns.
  external ffi.Pointer<ffi.Uint8> vm_snapshot_instructions;

  /// A function to be called during isolate group creation.
  /// See Dart_IsolateGroupCreateCallback.
  external Dart_IsolateGroupCreateCallback create_group;

  /// A function to be called during isolate
  /// initialization inside an existing isolate group.
  /// See Dart_InitializeIsolateCallback.
  external Dart_InitializeIsolateCallback initialize_isolate;

  /// A function to be called right before an isolate is shutdown.
  /// See Dart_IsolateShutdownCallback.
  external Dart_IsolateShutdownCallback shutdown_isolate;

  /// A function to be called after an isolate was shutdown.
  /// See Dart_IsolateCleanupCallback.
  external Dart_IsolateCleanupCallback cleanup_isolate;

  /// A function to be called after an isolate group is
  /// shutdown. See Dart_IsolateGroupCleanupCallback.
  external Dart_IsolateGroupCleanupCallback cleanup_group;

  external Dart_ThreadStartCallback thread_start;

  external Dart_ThreadExitCallback thread_exit;

  external Dart_FileOpenCallback file_open;

  external Dart_FileReadCallback file_read;

  external Dart_FileWriteCallback file_write;

  external Dart_FileCloseCallback file_close;

  external Dart_EntropySource entropy_source;

  /// A function to be called by the service isolate when it requires the
  /// vmservice assets archive. See Dart_GetVMServiceAssetsArchive.
  external Dart_GetVMServiceAssetsArchive get_service_assets;

  @ffi.Bool()
  external bool start_kernel_isolate;

  /// An external code observer callback function. The observer can be invoked
  /// as early as during the Dart_Initialize() call.
  external ffi.Pointer<Dart_CodeObserver> code_observer;

  /// Kernel blob registration callback function. See Dart_RegisterKernelBlobCallback.
  external Dart_RegisterKernelBlobCallback register_kernel_blob;

  /// Kernel blob unregistration callback function. See Dart_UnregisterKernelBlobCallback.
  external Dart_UnregisterKernelBlobCallback unregister_kernel_blob;
}

/// An isolate creation and initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM
/// needs to create an isolate. The callback should create an isolate
/// by calling Dart_CreateIsolateGroup and load any scripts required for
/// execution.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns NULL, it is the responsibility of this
/// function to ensure that Dart_ShutdownIsolate has been called if
/// required (for example, if the isolate was created successfully by
/// Dart_CreateIsolateGroup() but the root library fails to load
/// successfully, then the function should call Dart_ShutdownIsolate
/// before returning).
///
/// When the function returns NULL, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param script_uri The uri of the main source file or snapshot to load.
/// Either the URI of the parent isolate set in Dart_CreateIsolateGroup for
/// Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the
/// library tag handler of the parent isolate.
/// The callback is responsible for loading the program by a call to
/// Dart_LoadScriptFromKernel.
/// \param main The name of the main entry point this isolate will
/// eventually run.  This is provided for advisory purposes only to
/// improve debugging messages.  The main function is not invoked by
/// this function.
/// \param package_root Ignored.
/// \param package_config Uri of the package configuration file (either in format
/// of .packages or .dart_tool/package_config.json) for this isolate
/// to resolve package imports against. If this parameter is not passed the
/// package resolution of the parent isolate should be used.
/// \param flags Default flags for this isolate being spawned. Either inherited
/// from the spawning isolate or passed as parameters when spawning the
/// isolate from Dart code.
/// \param isolate_data The isolate data which was passed to the
/// parent isolate when it was created by calling Dart_CreateIsolateGroup().
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case of failures.
///
/// \return The embedder returns NULL if the creation and
/// initialization was not successful and the isolate if successful.
typedef Dart_IsolateGroupCreateCallback = ffi.Pointer<
    ffi.NativeFunction<
        Dart_Isolate Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<Dart_IsolateFlags>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>>;

/// An isolate is the unit of concurrency in Dart. Each isolate has
/// its own memory and thread of control. No state is shared between
/// isolates. Instead, isolates communicate by message passing.
///
/// Each thread keeps track of its current isolate, which is the
/// isolate which is ready to execute on the current thread. The
/// current isolate may be NULL, in which case no isolate is ready to
/// execute. Most of the Dart apis require there to be a current
/// isolate in order to function without error. The current isolate is
/// set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate.
typedef Dart_Isolate = ffi.Pointer<_Dart_Isolate>;

class _Dart_Isolate extends ffi.Opaque {}

/// An isolate initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM has created an
/// isolate within an existing isolate group (i.e. from the same source as an
/// existing isolate).
///
/// The callback should setup native resolvers and might want to set a custom
/// message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as
/// runnable.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns `false`, it is the responsibility of this
/// function to ensure that `Dart_ShutdownIsolate` has been called.
///
/// When the function returns `false`, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param child_isolate_data The callback data to associate with the new
/// child isolate.
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case the initialization fails.
///
/// \return The embedder returns true if the initialization was successful and
/// false otherwise (in which case the VM will terminate the isolate).
typedef Dart_InitializeIsolateCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>>;

/// An isolate shutdown callback function.
///
/// This callback, provided by the embedder, is called before the vm
/// shuts down an isolate.  The isolate being shutdown will be the current
/// isolate. It is safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateShutdownCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

/// An isolate cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate. There will be no current isolate and it is *not*
/// safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateCleanupCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

/// An isolate group cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate group.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
typedef Dart_IsolateGroupCleanupCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;

/// A thread start callback function.
/// This callback, provided by the embedder, is called after a thread in the
/// vm thread pool starts.
/// This function could be used to adjust thread priority or attach native
/// resources to the thread.
typedef Dart_ThreadStartCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// A thread death callback function.
/// This callback, provided by the embedder, is called before a thread in the
/// vm thread pool exits.
/// This function could be used to dispose of native resources that
/// are associated and attached to the thread, in order to avoid leaks.
typedef Dart_ThreadExitCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// Opens a file for reading or writing.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param name The name of the file to open.
/// \param write A boolean variable which indicates if the file is to
/// opened for writing. If there is an existing file it needs to truncated.
typedef Dart_FileOpenCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, ffi.Bool)>>;

/// Read contents of file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer allocated in the callback into which the contents
/// of the file are read into. It is the responsibility of the caller to
/// free this buffer.
/// \param file_length A variable into which the length of the file is returned.
/// In the case of an error this value would be -1.
/// \param stream Handle to the opened file.
typedef Dart_FileReadCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
            ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Void>)>>;

/// Write data into file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param data Buffer which needs to be written into the file.
/// \param length Length of the buffer.
/// \param stream Handle to the opened file.
typedef Dart_FileWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.IntPtr, ffi.Pointer<ffi.Void>)>>;

/// Closes the opened file.
///
/// Callback provided by the embedder for file operations. If the
/// embedder does not allow file operations this callback can be
/// NULL.
///
/// \param stream Handle to the opened file.
typedef Dart_FileCloseCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Dart_EntropySource = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>;

/// Callback provided by the embedder that is used by the vmservice isolate
/// to request the asset archive. The asset archive must be an uncompressed tar
/// archive that is stored in a Uint8List.
///
/// If the embedder has no vmservice isolate assets, the callback can be NULL.
///
/// \return The embedder must return a handle to a Uint8List containing an
/// uncompressed tar archive or null.
typedef Dart_GetVMServiceAssetsArchive
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>;

/// Optional callback provided by the embedder that is used by the VM to
/// implement registration of kernel blobs for the subsequent Isolate.spawnUri
/// If no callback is provided, the registration of kernel blobs will throw
/// an error.
///
/// \param kernel_buffer A buffer which contains a kernel program. Callback
/// should copy the contents of `kernel_buffer` as
/// it may be freed immediately after registration.
/// \param kernel_buffer_size The size of `kernel_buffer`.
///
/// \return A C string representing URI which can be later used
/// to spawn a new isolate. This C String should be scope allocated
/// or owned by the embedder.
/// Returns NULL if embedder runs out of memory.
typedef Dart_RegisterKernelBlobCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>;

/// Optional callback provided by the embedder that is used by the VM to
/// unregister kernel blobs.
/// If no callback is provided, the unregistration of kernel blobs will throw
/// an error.
///
/// \param kernel_blob_uri URI of the kernel blob to unregister.
typedef Dart_UnregisterKernelBlobCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>;
typedef Dart_IsolateGroup = ffi.Pointer<_Dart_IsolateGroup>;

class _Dart_IsolateGroup extends ffi.Opaque {}

/// Gets an id that uniquely identifies current isolate group.
///
/// It is the responsibility of the caller to free the returned ID.
typedef Dart_IsolateGroupId = ffi.Int64;

abstract class Dart_PerformanceMode {
  /// Balanced
  static const int Dart_PerformanceMode_Default = 0;

  /// Optimize for low latency, at the expense of throughput and memory overhead
  /// by performing work in smaller batches (requiring more overhead) or by
  /// delaying work (requiring more memory). An embedder should not remain in
  /// this mode indefinitely.
  static const int Dart_PerformanceMode_Latency = 1;

  /// Optimize for high throughput, at the expense of latency and memory overhead
  /// by performing work in larger batches with more intervening growth.
  static const int Dart_PerformanceMode_Throughput = 2;

  /// Optimize for low memory, at the expensive of throughput and latency by more
  /// frequently performing work.
  static const int Dart_PerformanceMode_Memory = 3;
}

/// A message notification callback.
///
/// This callback allows the embedder to provide a custom wakeup mechanism for
/// the delivery of inter-isolate messages. This function is called once per
/// message on an arbitrary thread. It is the responsibility of the embedder to
/// eventually call Dart_HandleMessage once per callback received with the
/// destination isolate set as the current isolate to process the message.
typedef Dart_MessageNotifyCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>;

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;

abstract class Dart_CoreType_Id {
  static const int Dart_CoreType_Dynamic = 0;
  static const int Dart_CoreType_Int = 1;
  static const int Dart_CoreType_String = 2;
}

abstract class Dart_TypedData_Type {
  static const int Dart_TypedData_kByteData = 0;
  static const int Dart_TypedData_kInt8 = 1;
  static const int Dart_TypedData_kUint8 = 2;
  static const int Dart_TypedData_kUint8Clamped = 3;
  static const int Dart_TypedData_kInt16 = 4;
  static const int Dart_TypedData_kUint16 = 5;
  static const int Dart_TypedData_kInt32 = 6;
  static const int Dart_TypedData_kUint32 = 7;
  static const int Dart_TypedData_kInt64 = 8;
  static const int Dart_TypedData_kUint64 = 9;
  static const int Dart_TypedData_kFloat32 = 10;
  static const int Dart_TypedData_kFloat64 = 11;
  static const int Dart_TypedData_kInt32x4 = 12;
  static const int Dart_TypedData_kFloat32x4 = 13;
  static const int Dart_TypedData_kFloat64x2 = 14;
  static const int Dart_TypedData_kInvalid = 15;
}

/// The arguments to a native function.
///
/// This object is passed to a native function to represent its
/// arguments and return value. It allows access to the arguments to a
/// native function by index. It also allows the return value of a
/// native function to be set.
typedef Dart_NativeArguments = ffi.Pointer<_Dart_NativeArguments>;

class _Dart_NativeArguments extends ffi.Opaque {}

abstract class Dart_NativeArgument_Type {
  static const int Dart_NativeArgument_kBool = 0;
  static const int Dart_NativeArgument_kInt32 = 1;
  static const int Dart_NativeArgument_kUint32 = 2;
  static const int Dart_NativeArgument_kInt64 = 3;
  static const int Dart_NativeArgument_kUint64 = 4;
  static const int Dart_NativeArgument_kDouble = 5;
  static const int Dart_NativeArgument_kString = 6;
  static const int Dart_NativeArgument_kInstance = 7;
  static const int Dart_NativeArgument_kNativeFields = 8;
}

class _Dart_NativeArgument_Value extends ffi.Opaque {}

typedef Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;

class _Dart_NativeArgument_Descriptor extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int index;
}

typedef Dart_NativeArgument_Value = _Dart_NativeArgument_Value;

/// An environment lookup callback function.
///
/// \param name The name of the value to lookup in the environment.
///
/// \return A valid handle to a string if the name exists in the
/// current environment or Dart_Null() if not.
typedef Dart_EnvironmentCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;

/// Native entry resolution callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a native entry resolver. This callback is used to map a
/// name/arity to a Dart_NativeFunction. If no function is found, the
/// callback should return NULL.
///
/// The parameters to the native resolver function are:
/// \param name a Dart string which is the name of the native function.
/// \param num_of_arguments is the number of arguments expected by the
/// native function.
/// \param auto_setup_scope is a boolean flag that can be set by the resolver
/// to indicate if this function needs a Dart API scope (see Dart_EnterScope/
/// Dart_ExitScope) to be setup automatically by the VM before calling into
/// the native function. By default most native functions would require this
/// to be true but some light weight native functions which do not call back
/// into the VM through the Dart API may not require a Dart scope to be
/// setup automatically.
///
/// \return A valid Dart_NativeFunction which resolves to a native entry point
/// for the native function.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntryResolver = ffi.Pointer<
    ffi.NativeFunction<
        Dart_NativeFunction Function(
            ffi.Handle, ffi.Int, ffi.Pointer<ffi.Bool>)>>;

/// A native function.
typedef Dart_NativeFunction
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_NativeArguments)>>;

/// Native entry symbol lookup callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a callback for mapping a native entry to a symbol. This callback
/// maps a native function entry PC to the native function name. If no native
/// entry symbol can be found, the callback should return NULL.
///
/// The parameters to the native reverse resolver function are:
/// \param nf A Dart_NativeFunction.
///
/// \return A const UTF-8 string containing the symbol name or NULL.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntrySymbol = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(Dart_NativeFunction)>>;

/// FFI Native C function pointer resolver callback.
///
/// See Dart_SetFfiNativeResolver.
typedef Dart_FfiNativeResolver = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, ffi.UintPtr)>>;

abstract class Dart_LibraryTag {
  static const int Dart_kCanonicalizeUrl = 0;
  static const int Dart_kImportTag = 1;
  static const int Dart_kKernelTag = 2;
}

/// The library tag handler is a multi-purpose callback provided by the
/// embedder to the Dart VM. The embedder implements the tag handler to
/// provide the ability to load Dart scripts and imports.
///
/// -- TAGS --
///
/// Dart_kCanonicalizeUrl
///
/// This tag indicates that the embedder should canonicalize 'url' with
/// respect to 'library'.  For most embedders, the
/// Dart_DefaultCanonicalizeUrl function is a sufficient implementation
/// of this tag.  The return value should be a string holding the
/// canonicalized url.
///
/// Dart_kImportTag
///
/// This tag is used to load a library from IsolateMirror.loadUri. The embedder
/// should call Dart_LoadLibraryFromKernel to provide the library to the VM. The
/// return value should be an error or library (the result from
/// Dart_LoadLibraryFromKernel).
///
/// Dart_kKernelTag
///
/// This tag is used to load the intermediate file (kernel) generated by
/// the Dart front end. This tag is typically used when a 'hot-reload'
/// of an application is needed and the VM is 'use dart front end' mode.
/// The dart front end typically compiles all the scripts, imports and part
/// files into one intermediate file hence we don't use the source/import or
/// script tags. The return value should be an error or a TypedData containing
/// the kernel bytes.
typedef Dart_LibraryTagHandler = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.Handle, ffi.Handle)>>;

/// Handles deferred loading requests. When this handler is invoked, it should
/// eventually load the deferred loading unit with the given id and call
/// Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is
/// recommended that the loading occur asynchronously, but it is permitted to
/// call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the
/// handler returns.
///
/// If an error is returned, it will be propagated through
/// `prefix.loadLibrary()`. This is useful for synchronous
/// implementations, which must propagate any unwind errors from
/// Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler
/// should return a non-error such as `Dart_Null()`.
typedef Dart_DeferredLoadHandler
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>;

/// Experimental support for Dart to Kernel parser isolate.
///
/// TODO(hausner): Document finalized interface.
abstract class Dart_KernelCompilationStatus {
  static const int Dart_KernelCompilationStatus_Unknown = -1;
  static const int Dart_KernelCompilationStatus_Ok = 0;
  static const int Dart_KernelCompilationStatus_Error = 1;
  static const int Dart_KernelCompilationStatus_Crash = 2;
  static const int Dart_KernelCompilationStatus_MsgFailed = 3;
}

class Dart_KernelCompilationResult extends ffi.Struct {
  @ffi.Int32()
  external int status;

  @ffi.Bool()
  external bool null_safety;

  external ffi.Pointer<ffi.Char> error;

  external ffi.Pointer<ffi.Uint8> kernel;

  @ffi.IntPtr()
  external int kernel_size;
}

abstract class Dart_KernelCompilationVerbosityLevel {
  static const int Dart_KernelCompilationVerbosityLevel_Error = 0;
  static const int Dart_KernelCompilationVerbosityLevel_Warning = 1;
  static const int Dart_KernelCompilationVerbosityLevel_Info = 2;
  static const int Dart_KernelCompilationVerbosityLevel_All = 3;
}

class Dart_SourceFile extends ffi.Struct {
  external ffi.Pointer<ffi.Char> uri;

  external ffi.Pointer<ffi.Char> source;
}

typedef Dart_StreamingWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>;
typedef Dart_CreateLoadingUnitCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.IntPtr,
            ffi.Pointer<ffi.Pointer<ffi.Void>>,
            ffi.Pointer<ffi.Pointer<ffi.Void>>)>>;
typedef Dart_StreamingCloseCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;

abstract class tarantool_message_type {
  static const int TARANTOOL_MESSAGE_CALL = 0;
  static const int TARANTOOL_MESSAGE_BATCH = 1;
  static const int TARANTOOL_MESSAGE_STOP = 2;
  static const int TARANTOOL_MESSAGE_BEGIN = 3;
  static const int TARANTOOL_MESSAGE_COMMIT = 4;
  static const int TARANTOOL_MESSAGE_ROLLBACK = 5;
  static const int tarantool_message_type_MAX = 6;
}

class tarantool_message_batch_element_t extends ffi.Struct {
  external tarantool_function function;

  external tarantool_function_argument input;

  external tarantool_function_argument output;

  @ffi.Bool()
  external bool failed;
}

typedef tarantool_function = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>;
typedef tarantool_function_argument = ffi.Pointer<ffi.Void>;

class tarantool_message_t extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external tarantool_function function;

  external tarantool_function_argument input;

  external tarantool_function_argument output;

  @Dart_Port()
  external int callback_send_port;

  external ffi.Pointer<ffi.Handle> callback_handle;

  external ffi.Pointer<ffi.Pointer<tarantool_message_batch_element_t>> batch;

  @ffi.Size()
  external int batch_size;

  @ffi.Bool()
  external bool failed;

  @ffi.UnsignedInt()
  external int owner;
}

class tarantool_tuple_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  @ffi.Size()
  external int size;
}

class tarantool_configuration extends ffi.Struct {
  @ffi.Size()
  external int box_output_buffer_capacity;

  @ffi.Double()
  external double message_loop_max_sleep_seconds;

  @ffi.Double()
  external double message_loop_regular_sleep_seconds;

  @ffi.Int()
  external int message_loop_max_empty_cycles;

  @ffi.Int()
  external int message_loop_empty_cycles_multiplier;

  @ffi.Int()
  external int message_loop_initial_empty_cycles;

  @ffi.Size()
  external int message_loop_ring_size;
}

typedef tarantool_configuration_t = tarantool_configuration;

class tarantool_message_loop_configuration extends ffi.Struct {
  @ffi.Double()
  external double message_loop_max_sleep_seconds;

  @ffi.Double()
  external double message_loop_regular_sleep_seconds;

  @ffi.Int()
  external int message_loop_max_empty_cycles;

  @ffi.Int()
  external int message_loop_empty_cycles_multiplier;

  @ffi.Int()
  external int message_loop_initial_empty_cycles;

  @ffi.Size()
  external int message_loop_ring_size;
}

typedef tarantool_message_loop_configuration_t
    = tarantool_message_loop_configuration;

class obuf extends ffi.Opaque {}

class tarantool_space_id_request_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Size()
  external int name_length;
}

class tarantool_space_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  external ffi.Pointer<tarantool_tuple_t> tuple;
}

class tarantool_space_count_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Int()
  external int iterator_type;

  external ffi.Pointer<tarantool_tuple_t> key;
}

class tarantool_space_select_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  external ffi.Pointer<tarantool_tuple_t> key;

  @ffi.Uint32()
  external int offset;

  @ffi.Uint32()
  external int limit;

  @ffi.Int()
  external int iterator_type;
}

class tarantool_space_update_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  external ffi.Pointer<tarantool_tuple_t> key;

  external ffi.Pointer<tarantool_tuple_t> operations;
}

class tarantool_space_upsert_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  external ffi.Pointer<tarantool_tuple_t> tuple;

  external ffi.Pointer<tarantool_tuple_t> operations;
}

class tarantool_space_iterator_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Int()
  external int type;

  external ffi.Pointer<tarantool_tuple_t> key;
}

class tarantool_index_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;

  external ffi.Pointer<tarantool_tuple_t> tuple;
}

class tarantool_index_count_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;

  external ffi.Pointer<tarantool_tuple_t> key;

  @ffi.Int()
  external int iterator_type;
}

class tarantool_index_id_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Size()
  external int name_length;
}

class tarantool_index_update_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;

  external ffi.Pointer<tarantool_tuple_t> key;

  external ffi.Pointer<tarantool_tuple_t> operations;
}

class tarantool_call_request_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> function;

  @ffi.Uint32()
  external int function_length;

  external ffi.Pointer<tarantool_tuple_t> input;
}

class tarantool_index_iterator_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;

  @ffi.Int()
  external int type;

  external ffi.Pointer<tarantool_tuple_t> key;
}

class tarantool_index_select_request_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;

  external ffi.Pointer<tarantool_tuple_t> key;

  @ffi.Uint32()
  external int offset;

  @ffi.Uint32()
  external int limit;

  @ffi.Int()
  external int iterator_type;
}

class tarantool_index_id_t extends ffi.Struct {
  @ffi.Uint32()
  external int space_id;

  @ffi.Uint32()
  external int index_id;
}

const int kNativeArgNumberPos = 0;

const int kNativeArgNumberSize = 8;

const int kNativeArgTypePos = 8;

const int kNativeArgTypeSize = 8;

const int NULL = 0;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int DART_FLAGS_CURRENT_VERSION = 12;

const int DART_INITIALIZE_PARAMS_CURRENT_VERSION = 7;

const String DART_KERNEL_ISOLATE_NAME = 'kernel-service';

const String DART_VM_SERVICE_ISOLATE_NAME = 'vm-service';

const String kSnapshotBuildIdCSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataCSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsCSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssCSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataCSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsCSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssCSymbol = '_kDartIsolateSnapshotBss';

const String kSnapshotBuildIdAsmSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataAsmSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsAsmSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssAsmSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataAsmSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsAsmSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssAsmSymbol = '_kDartIsolateSnapshotBss';
